layout.show()
coordinates_AMAK <- read.table("/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/AMAK_eparses/geneland_AMAK/input/coordinates.txt")
coordinates_DATR <- read.table("/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/DATR_eparses/geneland_DATR/input/coordinates.txt")
coordinates_AMAK <- read.table("/Users/jimmy.odonnell/Downloads/geneland_AMAK/input/coordinates.txt")
coordinates_AMAK <- read.table("/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/AMAK_eparses/geneland_AMAK/input/coordinates.txt")
coordinates_DATR <- read.table("/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/DATR_eparses/geneland_DATR/input/coordinates.txt")
coordinates_AMAK <- read.table("/Users/jimmy.odonnell/Downloads/geneland_AMAK/input/coordinates.txt")
coordinates_AMAK
coordinates_AMAK <- read.table("/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/AMAK_eparses/geneland_AMAK/input/coordinates.txt")
mcmc_dir_AMAK <- "/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/AMAK_eparses/geneland_AMAK/geneland_out/1/"
mcmc_dir_DATR <- "/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/DATR_eparses/geneland_DATR/geneland_out/"
par(mfcol=c(1,2))#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir#
)#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
par(mfcol=c(1,2))#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK#
)#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)
coordinates_DATR <- read.table("/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/DATR_eparses/geneland_DATR/input/coordinates.txt")
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
mcmc_dir_DATR <- "/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/DATR_eparses/geneland_DATR/output_2015-10-14_130412/"
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)
mcmc_dir_DATR <- "/Users/threeprime/Dropbox/Eparses_Connectivity/Analysis/DATR_eparses/geneland_DATR/output_2015-10-21_123923/"
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)
par(mfcol=c(1,2))#
#
# plot the first species#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
#
# plot the second species#
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
pdf(file = "geneland_both_species.pdf", width = 10, height = 5)#
# Set up plot for two plots#
par(mfcol=c(1,2))#
#
# plot the first species#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
#
# plot the second species#
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
dev.off()
postscript(file = "geneland_both_species.ps", width = 10, height = 5)
par(mfcol=c(1,2))#
#
# plot the first species#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
#
# plot the second species#
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
#
dev.off()
par(mfcol=c(1,2))#
#
# plot the first species#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
title(main = "Amphiprion akallopisos")
title(main = italic("Amphiprion akallopisos"))
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
title(main = italic("Amphiprion akallopisos"))
title(main = italics("Amphiprion akallopisos"))
par(mfcol=c(1,2))
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK, #
	main.title = "Amphiprion akallopisos"#
)
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK, #
	main.title = italics("Amphiprion akallopisos")#
)
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK, #
	main.title = italic("Amphiprion akallopisos")#
)
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK, #
	main.title = expression(italic("Amphiprion akallopisos"))#
)
par(mfcol=c(1,2))#
#
# plot the first species#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK, #
	main.title = expression(italic("Amphiprion akallopisos"))#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
title(main = italics("Amphiprion akallopisos"))#
#
# plot the second species#
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR, #
	main.title = expression(italic("Amphiprion akallopisos"))#
#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
par(mfcol=c(1,2))#
#
# plot the first species#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK, #
	main.title = expression(italic("Amphiprion akallopisos"))#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
title(main = italics("Amphiprion akallopisos"))#
#
# plot the second species#
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR, #
	main.title = expression(italic("Dascyllus trimaculatus"))#
#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
#
dev.off()
par(mfcol=c(1,2))#
#
# plot the first species#
plot_geneland(#
	coordinates = coordinates_AMAK, #
	path.mcmc = mcmc_dir_AMAK, #
	main.title = expression(italic("Amphiprion akallopisos"))#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)#
title(main = italics("Amphiprion akallopisos"))#
#
# plot the second species#
plot_geneland(#
	coordinates = coordinates_DATR, #
	path.mcmc = mcmc_dir_DATR, #
	main.title = expression(italic("Dascyllus trimaculatus"))#
#
)#
#
# overlay the map#
map(#
	database ='world2Hires', #
	xlim = c(30, 55), #
	ylim = c(-26, -4), #
	fill=TRUE, #
	col="gray", #
	boundary="gray", #
	interior="gray", #
	add=TRUE, #
	mar=c(4,4,0,4)#
	)
library(maps)#
map("state", interior = FALSE)#
map("state", boundary = FALSE, col="gray", add = TRUE)
library(maps)#
map("state", interior = FALSE)#
map("state", boundary = FALSE, col="gray", add = TRUE, fill = 2)
library(maps)
map("state", boundary = FALSE, col="gray", add = TRUE, fill = 2)
library(maps)
map("state", boundary = FALSE, col="gray", add = TRUE, fill = 2)
library(maps)#
map("state", interior = FALSE)#
map("state", boundary = FALSE, col="gray", add = TRUE, fill = 2)
library(maps)
library(maps)#
map("state", interior = TRUE)#
map("state", boundary = FALSE, col="gray", add = TRUE, fill = 2)
dat
dat <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/PS_urban_eDNA/Data/Analysis_20151125_1623/all_lib/OTUs_swarm/OTUs_BayesianVetted_decontam_rarefied.csv")
rowSums(dat)
dat[1:5,1:5]
dat <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/PS_urban_eDNA/Data/Analysis_20151125_1623/all_lib/OTUs_swarm/OTUs_BayesianVetted_decontam_rarefied.csv", row.names = 1)
dat[1:5,1:5]
rowSums(dat)
plot(rowSums(dat))
plot(sort(rowSums(dat)))
plot(sort(rowSums(dat), decreasing = TRUE))
which( sort(rowSums(dat), decreasing = TRUE) == 0)
which( sort(rowSums(dat), decreasing = TRUE) )
sort(rowSums(dat), decreasing = TRUE)
plot(log(sort(rowSums(dat), decreasing = TRUE)))
abline(h = 0)
abline(h = 1)
abline(h = 3, log = y)
abline(h = 3, log = "y")
plot(log(sort(rowSums(dat), decreasing = TRUE)))
plot(sort(rowSums(dat), decreasing = TRUE), log = "y")
plot(sort(rowSums(dat), decreasing = TRUE))
plot(sort(rowSums(dat), decreasing = TRUE), log = "y")
log(0)
log(1)
length(which(rowSums(dat) == 0))
table(rowSums(dat))
hist(rowSums(dat))
?hist
hist(rowSums(dat), breaks = 50)
hist(rowSums(dat), breaks = 100)
hist(rowSums(dat), breaks = 1000)
table(rowSums(dat))
hist(rowSums(dat), breaks = c(0, 10, 100, 1000, 10000))
hist(rowSums(dat), breaks = c(0, 10, 100, 1000, 10000, max(rowSums(dat))))
hist(rowSums(dat), breaks = c(0, 10, max(rowSums(dat))))
table(rowSums(dat))
plot(table(rowSums(dat)))
plot(log(table(rowSums(dat))))
plot(table(rowSums(dat)), log = "x")
plot(sort(rowSums(dat), decreasing = TRUE))
plot(sort(rowSums(dat), decreasing = TRUE), log = "y")
plot(sort(rowSums(dat), decreasing = TRUE))
plot(sort(rowSums(dat), decreasing = TRUE), log = "y")
plot(sort(rowSums(dat), decreasing = TRUE), log = "y", ylab = "sum of reads across samples")
plot(sort(rowSums(dat), decreasing = TRUE), log = "y", ylab = "log(total reads across samples)")
text(nrow(data), max(rowSums(dat)), "stuff")
max(rowSums(dat))
nrow(data)
nrow(dat)
text(nrow(dat), max(rowSums(dat)), "stuff")
abline(h = 1)
abline(h = 10, lty = "2")
abline(h = 10, lty = 2)
plot(table(rowSums(dat)), log = "x")
plot(sort(rowSums(dat), decreasing = TRUE))
abline(h = 10, lty = 2)
plot(#
	sort(rowSums(dat), decreasing = TRUE), #
	log = "y", #
	ylab = "log(total reads across samples)"#
	xlab = "OTU index"#
	)#
abline(h = 10, lty = 2)
plot(
sort(rowSums(dat), decreasing = TRUE), #
	log = "y", #
	ylab = "log(total reads across samples)", #
	xlab = "OTU index"#
	)
abline(h = 10, lty = 2)
text(nrow(dat), 11, "10")
text(nrow(dat), 12, "10")
text(nrow(dat), 13, "10")
plot(#
	sort(rowSums(dat), decreasing = TRUE), #
	log = "y", #
	ylab = "log(total reads across samples)", #
	xlab = "OTU index"#
	)#
abline(h = 10, lty = 2)#
#
text(nrow(dat), 13, "10")
length(which(rowSums(dat) == 0))
length(which(rowSums(dat) > 10))
length(which(rowSums(dat) > 10))/nrow(dat)
nrow(dat)
1812 -138
length(which(rowSums(dat) == 0))
no_counts <- length(which(rowSums(dat) == 0))
text(nrow(dat), max(rowSums(dat)), paste(no_counts, "reads had no counts"))
text(nrow(dat), max(rowSums(dat)), paste(no_counts, "reads had no counts"), pos = 2)
plot(#
	sort(rowSums(dat), decreasing = TRUE), #
	log = "y", #
	ylab = "log(total reads across samples)", #
	xlab = "OTU index"#
	)#
abline(h = 10, lty = 2)#
#
text(nrow(dat), 13, "10")#
# how many have no counts?#
no_counts <- length(which(rowSums(dat) == 0))#
text(nrow(dat), max(rowSums(dat)), paste(no_counts, "reads had no counts"), pos = 2)
length(which(rowSums(dat) > 10))/nrow(dat)
# another way of looking at data#
plot(table(rowSums(dat)), log = "x")
9*8
10*8
80+72
blast_results <- read.table("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Lemonade/Data/blast_20151125_1530/blast_results_all.txt")
blast_results <- read.table("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Lemonade/Data/blast_20151125_1530/blast_results_all.txt", sep = "\t")
head(blast_results)
blast_results <- read.table("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Lemonade/Data/blast_20151125_1530/blast_results_all.txt", sep = "\t")#
#
# table order: output_format="6 qseqid sallseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle"#
#
evalue_col=11#
bitscore_col=12#
plot(#
	x = blast_results[, evalue_col], #
	y = blast_results[, bitscore_col], #
	xlab = "evalue", #
	ylab = "bitscore"#
	)
plot(#
	x = blast_results[, evalue_col], #
	y = blast_results[, bitscore_col], #
	xlab = "evalue", #
	ylab = "bitscore", #
	log = "x"#
	)
blast_results <- read.table("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Lemonade/Data/blast_20151125_1530/blast_results_all.txt", sep = "\t")#
#
# table order: output_format="6 qseqid sallseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle"#
#
evalue_col=11#
bitscore_col=12#
plot(#
	x = blast_results[, evalue_col], #
	y = blast_results[, bitscore_col], #
	# log = "x", #
	xlab = "evalue", #
	ylab = "bitscore", #
	)
unique(blast_results[ , query_col ])
blast_results <- read.table("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Lemonade/Data/blast_20151125_1530/blast_results_all.txt", sep = "\t")#
#
# table order: output_format="6 qseqid sallseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle"#
#
query_col=1#
evalue_col=11#
bitscore_col=12#
tax_col=13#
#
plot(#
	x = blast_results[, evalue_col], #
	y = blast_results[, bitscore_col], #
	# log = "x", #
	xlab = "evalue", #
	ylab = "bitscore", #
	)#
dev.off()#
#
unique(blast_results[ , query_col ])#
#
# blast_results[ , ]
query_seq <- unique(blast_results[ , query_col ])
blast_results[ , query_col ] == query_seq[1]
blast_results[
blast_results[ , query_col ] == query_seq[1]
, ]
blast_results[ #
blast_results[ , query_col ] == query_seq[1]#
, bitscore_col]
query_seq <- unique(blast_results[ , query_col ])#
#
blast_results[ #
	blast_results[ , query_col ] == query_seq[1], #
	bitscore_col#
	]
mylist <- list(#
  x = c(1, 4, 6, 7, 9, 5, 4, 3, 3), #
  y = c(4, 66, 5, 8, 3, 6, 5), #
  z = c(4, 8, 6, 9, 55, 78, 3, 2, 2, 0, 0, 0)#
)#
intersect2 <- function(...) {#
  args <- list(...)#
  nargs <- length(args)#
  if(nargs <= 1) {#
    if(nargs == 1 && is.list(args[[1]])) {#
      do.call("intersect2", args[[1]])#
    } else {#
      stop("cannot evaluate intersection fewer than 2 arguments")#
    }#
  } else if(nargs == 2) {#
    intersect(args[[1]], args[[2]])#
  } else {#
    intersect(args[[1]], intersect2(args[-1]))#
  }#
}#
intersect2(mylist)
Reduce(intersect(mylist))
Reduce(intersect, mylist)
df1 <- data.frame(a = 1:5, b = 1:5, #
                  row.names = letters[1:5]) # letters a to e#
df2 <- data.frame(a = 1:5, b = 1:5, #
                  row.names = letters[3:7]) # letters c to g#
df3 <- data.frame(a = 1:5, b = 1:5, #
                  row.names = letters[c(1,2,3,5,7)]) # letters a, b, c, e, and g#
#
dfList <- list(df1, df2, df3)
dfList
df1 <- data.frame(a = 1:5, b = 1:5, #
                  row.names = letters[1:5]) # letters a to e#
df2 <- data.frame(a = 1:5, b = 1:5, #
                  row.names = letters[3:7]) # letters c to g#
df3 <- data.frame(a = 1:5, b = 1:5, #
                  row.names = letters[c(1,2,3,5,7)]) # letters a, b, c, e, and g#
#
dfList <- list(df1, df2, df3)#
#
idx <- Reduce(intersect, lapply(dfList, rownames))#
#
#Extract data:#
df1[idx, ]#
#
# If you want to keep the corresponding rows from all data frames, you could replace the last step, df1[idx, ], with the following command:#
do.call(rbind, lapply(dfList, "[", idx, ))
dfList
idx
library(plyr)
join(df1, df2,
type = "inner")
rbeta
?rbeta
x <- seq(0, 1, length = 21)#
dbeta(x, 1, 1)#
pbeta(x, 1, 1)#
#
## Visualization, including limit cases:#
pl.beta <- function(a,b, asp = if(isLim) 1, ylim = if(isLim) c(0,1.1)) {#
  if(isLim <- a == 0 || b == 0 || a == Inf || b == Inf) {#
    eps <- 1e-10#
    x <- c(0, eps, (1:7)/16, 1/2+c(-eps,0,eps), (9:15)/16, 1-eps, 1)#
  } else {#
    x <- seq(0, 1, length = 1025)#
  }#
  fx <- cbind(dbeta(x, a,b), pbeta(x, a,b), qbeta(x, a,b))#
  f <- fx; f[fx == Inf] <- 1e100#
  matplot(x, f, ylab="", type="l", ylim=ylim, asp=asp,#
          main = sprintf("[dpq]beta(x, a=%g, b=%g)", a,b))#
  abline(0,1,     col="gray", lty=3)#
  abline(h = 0:1, col="gray", lty=3)#
  legend("top", paste0(c("d","p","q"), "beta(x, a,b)"),#
         col=1:3, lty=1:3, bty = "n")#
  invisible(cbind(x, fx))#
}#
pl.beta(3,1)
pl.beta(2, 4)
pl.beta(3, 7)
pl.beta(3, 7, asp=1)
pl.beta(0, 0)   ## point masses at  {0, 1}
pl.beta(0, 2)   ## point mass at 0 ; the same as
pl.beta(3,1)
stop("")
stop("
'imatrix' must be an object
")
stop("
must be a matrix
")
stop(
stuff is wrong
stop(
stuff is wrong
test_matrix <- read.table("/Users/threeprime/Dropbox/NIMBioS_END/extinctions/Data/nets_emp/DIHI.txt")
test_matrix
(test_matrix)
imatrix <- test_matrix
ranim <- runif(nrow(imatrix))
ranim
plot(ranim)
rplants <- runif(ncol(imatrix))
deadPlants <- NULL
deadPlants
deadAnimals <- NULL
targetGuild <- "plant"
target <- 1
bigmat <- rep(imatrix, 1000)
load("/Users/threeprime/Dropbox/Compute/R/general/lsos.RData")
lsos()
length(bigmat)
target
if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall#
  	")}
class(imatrix)
as.matrix(imatrix)
imatrix <- as.matrix(imatrix)
imatrix
if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall#
  	")}
if(class(ranim)!="numeric" || class(rplants) != "numeric" || max(c(max(ranim),max(rplants)))>1 || min(c(min(ranim),min(rplants)))<0){stop("#
  	'ranim' & 'rplants' must be numeric vectors with values ranging between 0 and 1#
  	")}
if((targetGuild%in%c("animal","plant"))==FALSE){stop('#
  	Invalid target guild for primary extinction. Valid targets guilds are "animal" and "plant"#
  	')}
if(is.numeric(target)==FALSE){stop('#
  	Invalid value for the "target" argument. You may specify a single species by entering its row or column number or you may use a vector of relative probabilites for all species in the target guild.#
  	')}
if(is.null(deadAnimals)==FALSE && class(deadAnimals)!= "integer"){stop("#
  	deadAnimals must be either NULL or an integer vector specifying the row numbers of animals considered to be extinct on the original matrix#
  	")}
if(is.null(deadPlants)==FALSE && class(deadPlants)!= "integer"){stop("#
  	deadPlants must be either NULL an integer vector specifying the column numbers of plants considered to be extinct on the original matrix#
  	")}
if(length(ranim)!= nrow(imatrix)){stop("#
  	The length of vector'ranim' must be equal to number of rows (i.e. animal species) in 'imatrix'#
  	")}
if(length(rplants)!= ncol(imatrix)){stop("#
  	The length of vector'rplants' must be equal to number of columns (i.e. plant species) in 'imatrix'#
  	")}
nanim <- nrow(imatrix)#
  npla <- ncol(imatrix)#
  plants <- 1:npla#
  animals <- 1:nanim#
  plantNA <- 1:npla#
  animNA <- 1:nanim#
  plantNA[deadPlants] <- NA#
  animNA[deadAnimals] <- NA
animNA
degree_when_lost_plants <- c()#
  degree_when_lost_animals <- c()
M <- array(0,dim=c(nanim,npla,2))
M
dim(imatrix)
sum(imatrix[,1])
imatrix[,1]
for(i in 1:npla){#
    M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
  } #matrix of plant dependence on each animal
for(i in 1:nanim){#
    M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
  } #matrix of animal dependence on each plant
targetGuild
target
coext_animals <- c()#
  coext_plants <- c()
if(length(target)==1){#
    if(targetGuild=="animal"){#
      if(target %in% deadAnimals){stop('Specified target species for the primary extinction is already extinct')}#
      coext_animals <- target#
      degree_when_lost_animals <- 1 #stores the degree of the extinction event of every animal species lost during the coextinction cascade. #
    }#
    if(targetGuild=="plant"){#
      if(target %in% deadPlants){stop('Specified target species for the primary extinction is already extinct')}#
      coext_plants <- target#
      degree_when_lost_plants <- 1#
    }
}else{#
    nspecies <- switch(targetGuild,animal = nanim, plant = npla)#
    if(length(target)==nspecies){#
      if(targetGuild =="animal"){#
        alive <- animals[is.na(animNA)==F]#
        coext_animals <- sample(c(alive,0),1,prob = c(target[is.na(animNA)==F],0))#
        degree_when_lost_animals <- 1#
      }#
      if(targetGuild =="plant"){#
        alive <- plants[is.na(plantNA)==F]#
        coext_plants <- sample(c(alive,0),1,prob = c(target[is.na(plantNA)==F],0))#
        degree_when_lost_plants <- 1#
      }#
    }else{#
      stop('Length of "target" must be 1 (specifying a single species within the target guild) or else be equal to the number of species in the target guild (specifying probabilities of primary extinction for each species in the target guild)')#
    }#
  }
coext_plants
coext_animals
coext_plants
degree_when_lost_plants
M
dim(M)
coext_animals
coext_plants
imatrix[coext_animals,] <- 0 #
  imatrix[,coext_plants] <- 0
lostanimals <- coext_animals #final list of animals which were "alive" in the original community but became extinct during this primary extinction + extinction cascade#
  lostplants <- coext_plants
coext_animals
coext_plants
rows
rows()
cols()
cols
nrows
ncols
stuff <- "things"
list(stuff = stuff)
?switch
col
row
column
row
switch("plant", animal = 4, plant = 3)
switch("plant", animal = 4, plant = 2)
switch("plant", animal = 4, plant = 1)
switch("plant", animal = 4, plan2t = 5)
setwd("/Users/threeprime/Dropbox/NIMBioS_END/extinctions/Analysis")
data_dir <- file.path("..", "Data")#
fig_dir <- file.path("..", "Figures")#
source("functions/netcascade_JO.R")#
source("functions/extinction_cascader.R")#
#
beta.par <- matrix(c(0.1, 1, 0.5, 1, 1, 1, 3, 3, 4, 0.1, 0.2, 0.2), byrow = TRUE, ncol = 2)#
rownames(beta.par)=c("exp","power","unif","normal","left", "bimod")#
R_options <- c("VA_low", "VA_med", "VA_high", rownames(beta.par))#
#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
#
# load all networks in that directory#
emp_nets<-dir(path = emp_net_path) #Plant-pollinator weighted nets#
#
mat_empirical <- list()#
#
for(p in 1:length(emp_nets)){#
	mat_empirical[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_nets[p])))#
}#
mat_empirical[[4]] <- NULL#
#
R_by_guild <- expand.grid(R_options, R_options)#
#
R_combo_out <- list()#
#
for(Rcombo in 1:nrow(R_by_guild)){#
	current_Rrows <- as.character(R_by_guild[Rcombo,1])#
	current_Rcols <- as.character(R_by_guild[Rcombo,2])#
	# DO THE SIMULATIONS ON EACH NETWORK#
	stored_events <- list()#
	just_extinctions <- list()#
	extinctions_by_guild <- list()#
	total_extinctions <- list()#
	total_cascades <- list()#
	cascade_frequency <- list()#
	for(i in 1:length(mat_empirical)){#
		mat <- mat_empirical[[i]]#
		if(min(c(rowSums(mat), colSums(mat))) == 0){#
		stop("Hey, you have a species in your network that does not interact with any other species. The following functions will get stuck.")}#
		m<-nrow(mat)#
		n<-ncol(mat)#
		stored_events[[i]] <- extinction_cascader(imatrix = mat, R_row = current_Rrows, R_col = current_Rcols, nsims = 10000)#
		just_extinctions[[i]] <- lapply(stored_events[[i]], "[", c("lost_cols", "lost_rows"))#
		extinctions_by_guild[[i]] <- do.call(rbind, lapply(just_extinctions[[i]], lengths))#
		total_extinctions[[i]] <- rowSums(extinctions_by_guild[[i]])#
		total_cascades[[i]] <- sum(total_extinctions[[i]] > 1)#
		cascade_frequency[[i]] <- total_cascades[[i]]/length(stored_events[[i]])#
	}#
#
	R_combo_out[[Rcombo]] <- list(stored_events, just_extinctions, extinctions_by_guild, total_extinctions, total_cascades, cascade_frequency)#
#
}#
#--------------------PLOTTING---------------------------------------#
#
# boxplot(sum(number_cascades > 1)/length(number_cascades))
