dfList
idx
library(plyr)
join(df1, df2,
type = "inner")
rbeta
?rbeta
x <- seq(0, 1, length = 21)#
dbeta(x, 1, 1)#
pbeta(x, 1, 1)#
#
## Visualization, including limit cases:#
pl.beta <- function(a,b, asp = if(isLim) 1, ylim = if(isLim) c(0,1.1)) {#
  if(isLim <- a == 0 || b == 0 || a == Inf || b == Inf) {#
    eps <- 1e-10#
    x <- c(0, eps, (1:7)/16, 1/2+c(-eps,0,eps), (9:15)/16, 1-eps, 1)#
  } else {#
    x <- seq(0, 1, length = 1025)#
  }#
  fx <- cbind(dbeta(x, a,b), pbeta(x, a,b), qbeta(x, a,b))#
  f <- fx; f[fx == Inf] <- 1e100#
  matplot(x, f, ylab="", type="l", ylim=ylim, asp=asp,#
          main = sprintf("[dpq]beta(x, a=%g, b=%g)", a,b))#
  abline(0,1,     col="gray", lty=3)#
  abline(h = 0:1, col="gray", lty=3)#
  legend("top", paste0(c("d","p","q"), "beta(x, a,b)"),#
         col=1:3, lty=1:3, bty = "n")#
  invisible(cbind(x, fx))#
}#
pl.beta(3,1)
pl.beta(2, 4)
pl.beta(3, 7)
pl.beta(3, 7, asp=1)
pl.beta(0, 0)   ## point masses at  {0, 1}
pl.beta(0, 2)   ## point mass at 0 ; the same as
pl.beta(3,1)
stop("")
stop("
'imatrix' must be an object
")
stop("
must be a matrix
")
stop(
stuff is wrong
stop(
stuff is wrong
test_matrix <- read.table("/Users/threeprime/Dropbox/NIMBioS_END/extinctions/Data/nets_emp/DIHI.txt")
test_matrix
(test_matrix)
imatrix <- test_matrix
ranim <- runif(nrow(imatrix))
ranim
plot(ranim)
rplants <- runif(ncol(imatrix))
deadPlants <- NULL
deadPlants
deadAnimals <- NULL
targetGuild <- "plant"
target <- 1
bigmat <- rep(imatrix, 1000)
load("/Users/threeprime/Dropbox/Compute/R/general/lsos.RData")
lsos()
length(bigmat)
target
if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall#
  	")}
class(imatrix)
as.matrix(imatrix)
imatrix <- as.matrix(imatrix)
imatrix
if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall#
  	")}
if(class(ranim)!="numeric" || class(rplants) != "numeric" || max(c(max(ranim),max(rplants)))>1 || min(c(min(ranim),min(rplants)))<0){stop("#
  	'ranim' & 'rplants' must be numeric vectors with values ranging between 0 and 1#
  	")}
if((targetGuild%in%c("animal","plant"))==FALSE){stop('#
  	Invalid target guild for primary extinction. Valid targets guilds are "animal" and "plant"#
  	')}
if(is.numeric(target)==FALSE){stop('#
  	Invalid value for the "target" argument. You may specify a single species by entering its row or column number or you may use a vector of relative probabilites for all species in the target guild.#
  	')}
if(is.null(deadAnimals)==FALSE && class(deadAnimals)!= "integer"){stop("#
  	deadAnimals must be either NULL or an integer vector specifying the row numbers of animals considered to be extinct on the original matrix#
  	")}
if(is.null(deadPlants)==FALSE && class(deadPlants)!= "integer"){stop("#
  	deadPlants must be either NULL an integer vector specifying the column numbers of plants considered to be extinct on the original matrix#
  	")}
if(length(ranim)!= nrow(imatrix)){stop("#
  	The length of vector'ranim' must be equal to number of rows (i.e. animal species) in 'imatrix'#
  	")}
if(length(rplants)!= ncol(imatrix)){stop("#
  	The length of vector'rplants' must be equal to number of columns (i.e. plant species) in 'imatrix'#
  	")}
nanim <- nrow(imatrix)#
  npla <- ncol(imatrix)#
  plants <- 1:npla#
  animals <- 1:nanim#
  plantNA <- 1:npla#
  animNA <- 1:nanim#
  plantNA[deadPlants] <- NA#
  animNA[deadAnimals] <- NA
animNA
degree_when_lost_plants <- c()#
  degree_when_lost_animals <- c()
M <- array(0,dim=c(nanim,npla,2))
M
dim(imatrix)
sum(imatrix[,1])
imatrix[,1]
for(i in 1:npla){#
    M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
  } #matrix of plant dependence on each animal
for(i in 1:nanim){#
    M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
  } #matrix of animal dependence on each plant
targetGuild
target
coext_animals <- c()#
  coext_plants <- c()
if(length(target)==1){#
    if(targetGuild=="animal"){#
      if(target %in% deadAnimals){stop('Specified target species for the primary extinction is already extinct')}#
      coext_animals <- target#
      degree_when_lost_animals <- 1 #stores the degree of the extinction event of every animal species lost during the coextinction cascade. #
    }#
    if(targetGuild=="plant"){#
      if(target %in% deadPlants){stop('Specified target species for the primary extinction is already extinct')}#
      coext_plants <- target#
      degree_when_lost_plants <- 1#
    }
}else{#
    nspecies <- switch(targetGuild,animal = nanim, plant = npla)#
    if(length(target)==nspecies){#
      if(targetGuild =="animal"){#
        alive <- animals[is.na(animNA)==F]#
        coext_animals <- sample(c(alive,0),1,prob = c(target[is.na(animNA)==F],0))#
        degree_when_lost_animals <- 1#
      }#
      if(targetGuild =="plant"){#
        alive <- plants[is.na(plantNA)==F]#
        coext_plants <- sample(c(alive,0),1,prob = c(target[is.na(plantNA)==F],0))#
        degree_when_lost_plants <- 1#
      }#
    }else{#
      stop('Length of "target" must be 1 (specifying a single species within the target guild) or else be equal to the number of species in the target guild (specifying probabilities of primary extinction for each species in the target guild)')#
    }#
  }
coext_plants
coext_animals
coext_plants
degree_when_lost_plants
M
dim(M)
coext_animals
coext_plants
imatrix[coext_animals,] <- 0 #
  imatrix[,coext_plants] <- 0
lostanimals <- coext_animals #final list of animals which were "alive" in the original community but became extinct during this primary extinction + extinction cascade#
  lostplants <- coext_plants
coext_animals
coext_plants
rows
rows()
cols()
cols
nrows
ncols
stuff <- "things"
list(stuff = stuff)
?switch
col
row
column
row
switch("plant", animal = 4, plant = 3)
switch("plant", animal = 4, plant = 2)
switch("plant", animal = 4, plant = 1)
switch("plant", animal = 4, plan2t = 5)
hsb2 <- read.table('http://www.ats.ucla.edu/stat/r/faq/hsb2.csv', header=T, sep=",")
hsb2[1:10,]
l <- reshape(hsb2, #
  varying = c("read", "write", "math", "science", "socst"), #
  v.names = "score",#
  timevar = "subj", #
  times = c("read", "write", "math", "science", "socst"), #
  new.row.names = 1:1000,#
  direction = "long")
l
load("/Users/threeprime/Dropbox/Compute/R/general/lsos.RData")
data_dir <- file.path("..", "Data")#
fig_dir <- file.path("..", "Figures")#
source("functions/netcascade_JO.R")#
source("functions/extinction_cascader.R")#
#
beta.par <- matrix(c(0.1, 1, 0.5, 1, 1, 1, 3, 3, 4, 0.1, 0.2, 0.2), byrow = TRUE, ncol = 2)#
rownames(beta.par)=c("exp","power","unif","normal","left", "bimod")#
R_options <- c("VA_low", "VA_med", "VA_high", rownames(beta.par))#
#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
#
# load all networks in that directory#
emp_nets<-dir(path = emp_net_path) #Plant-pollinator weighted nets#
#
mat_empirical <- list()#
#
for(p in 1:length(emp_nets)){#
	mat_empirical[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_nets[p])))#
}#
mat_empirical[[4]] <- NULL#
#
R_by_guild <- expand.grid(R_options, R_options)#
############################################################
#------------- RUN THE SIMULATIONS#
############################################################
N_iterations <- 100#
#
R_combo_out <- list()#
#
for(Rcombo in 1:nrow(R_by_guild)){#
	current_Rrows <- as.character(R_by_guild[Rcombo,1])#
	current_Rcols <- as.character(R_by_guild[Rcombo,2])#
	# DO THE SIMULATIONS ON EACH NETWORK#
	stored_events <- list()#
	just_extinctions <- list()#
	extinctions_by_guild <- list()#
	total_extinctions <- list()#
	total_cascades <- list()#
	cascade_frequency <- list()#
	for(i in 1:length(mat_empirical)){#
		mat <- mat_empirical[[i]]#
		if(min(c(rowSums(mat), colSums(mat))) == 0){#
		stop("Hey, you have a species in your network that does not interact with any other species. The following functions will get stuck.")}#
		m<-nrow(mat)#
		n<-ncol(mat)#
		stored_events[[i]] <- extinction_cascader(imatrix = mat, R_row = current_Rrows, R_col = current_Rcols, nsims = N_iterations)#
		just_extinctions[[i]] <- lapply(stored_events[[i]], "[", c("lost_cols", "lost_rows"))#
		extinctions_by_guild[[i]] <- do.call(rbind, lapply(just_extinctions[[i]], lengths))#
		total_extinctions[[i]] <- rowSums(extinctions_by_guild[[i]])#
		total_cascades[[i]] <- sum(total_extinctions[[i]] > 1)#
		cascade_frequency[[i]] <- total_cascades[[i]]/length(stored_events[[i]])#
	}#
#
	R_combo_out[[Rcombo]] <- list(stored_events, just_extinctions, extinctions_by_guild, total_extinctions, total_cascades, cascade_frequency)#
#
}#
#
lsos()
load("/Users/threeprime/Dropbox/Compute/R/general/lsos.RData")
setwd("/Users/threeprime/Dropbox/NIMBioS_END/extinctions/Analysis")
data_dir <- file.path("..", "Data")#
fig_dir <- file.path("..", "Figures")#
source("functions/netcascade_JO.R")#
source("functions/extinction_cascader.R")#
#
beta.par <- matrix(c(0.1, 1, 0.5, 1, 1, 1, 3, 3, 4, 0.1, 0.2, 0.2), byrow = TRUE, ncol = 2)#
rownames(beta.par)=c("exp","power","unif","normal","left", "bimod")#
R_options <- c("VA_low", "VA_med", "VA_high", rownames(beta.par))#
#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
#
# load all networks in that directory#
emp_nets<-dir(path = emp_net_path) #Plant-pollinator weighted nets#
#
mat_empirical <- list()#
#
for(p in 1:length(emp_nets)){#
	mat_empirical[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_nets[p])))#
}#
mat_empirical[[4]] <- NULL#
#
R_by_guild <- expand.grid(R_options, R_options)#
############################################################
#------------- RUN THE SIMULATIONS#
############################################################
N_iterations <- 100#
#
R_combo_out <- list()#
#
for(Rcombo in 1:nrow(R_by_guild)){#
	current_Rrows <- as.character(R_by_guild[Rcombo,1])#
	current_Rcols <- as.character(R_by_guild[Rcombo,2])#
	# DO THE SIMULATIONS ON EACH NETWORK#
	stored_events <- list()#
	just_extinctions <- list()#
	extinctions_by_guild <- list()#
	total_extinctions <- list()#
	total_cascades <- list()#
	cascade_frequency <- list()#
	for(i in 1:length(mat_empirical)){#
		mat <- mat_empirical[[i]]#
		if(min(c(rowSums(mat), colSums(mat))) == 0){#
		stop("Hey, you have a species in your network that does not interact with any other species. The following functions will get stuck.")}#
		m<-nrow(mat)#
		n<-ncol(mat)#
		stored_events[[i]] <- extinction_cascader(imatrix = mat, R_row = current_Rrows, R_col = current_Rcols, nsims = N_iterations)#
		just_extinctions[[i]] <- lapply(stored_events[[i]], "[", c("lost_cols", "lost_rows"))#
		extinctions_by_guild[[i]] <- do.call(rbind, lapply(just_extinctions[[i]], lengths))#
		total_extinctions[[i]] <- rowSums(extinctions_by_guild[[i]])#
		total_cascades[[i]] <- sum(total_extinctions[[i]] > 1)#
		cascade_frequency[[i]] <- total_cascades[[i]]/length(stored_events[[i]])#
	}#
#
	R_combo_out[[Rcombo]] <- list(stored_events, just_extinctions, extinctions_by_guild, total_extinctions, total_cascades, cascade_frequency)#
#
}#
#
lsos()
save(R_combo_out, file = "R_72_net_6_iter100.RData")
R_combo_out
length(R_combo_out)
nrow(R_by_guild)
R_by_guild
R_combo_out
R_combo_out[[1]]
names(R_combo_out)
R_by_guild[1,]
paste(R_by_guild[1,])
paste(R_by_guild[1,], sep = "")
collapse(R_by_guild[1,])
coll(R_by_guild[1,])
paste(R_by_guild[1,], sep "", collapse = "")
R_by_guild[1,]
paste(as.character(R_by_guild[1,]), sep "", collapse = "")
paste(R_by_guild[1,], sep = "", collapse = "")
paste(R_by_guild[1,], sep = "", collapse = "")
as.character(R_by_guild[1,])
R_by_guild
as.character(R_by_guild)
class(R_by_guild)
as.matrix(R_by_guild)
paste(as.matrix(R_by_guild[1,]), sep = "", collapse = "")
apply(X = as.matrix(R_by_guild), MARGIN = 1, FUN = function(x) paste(x, sep = "", collapse = ""))
names(R_combo_out) <- apply(X = as.matrix(R_by_guild), MARGIN = 1, FUN = function(x) paste(x, sep = "", collapse = ""))
save(R_combo_out, file = "R_72_net_6_iter100.RData")
length(R_combo_out[[1]])
length(R_combo_out[[1]])
length(R_combo_out[[1]][[1]])
length(R_combo_out[[1]][[1]])
length(R_combo_out[[1]][[1]][[1]])
length(R_combo_out[[1]][[1]][[2]])
length(R_combo_out[[1]][[1]][[3]])
R_combo_out[[1]][[1]][[3]]
R_combo_out[[1]][[1]][[9]]
R_combo_out[[1]][[1]][[8]]
R_combo_out[[1]][[2]][[8]]
R_combo_out[[1]][[3]][[8]]
R_combo_out[[1]][[4]][[8]]
R_combo_out[[1]][[2]][[8]]
R_combo_out[[1]][[3]][[8]]
R_combo_out[[1]][[4]][[8]]
R_combo_out[[1]][[3]][[8]]
R_combo_out[[1]][[4]][[8]]
R_combo_out[[1]][[8]][[8]]
R_combo_out[[1]][[7]][[8]]
R_combo_out[[1]][[6]][[8]]
R_combo_out[[1]][[1]][[8]]
R_combo_out[[1]][[1]][[2]]
R_combo_out[[1]][[1]][[9]]
R_combo_out[[1]][[1]][[8]]
R_combo_out[[1]][[1]][[2]]
R_combo_out[[1]][[1]][[1]]
R_combo_out[[1]][[1]][[2]]
R_combo_out[[1]][[1]][[3]]
names(R_combo_out)
names(R_combo_out[[1]])
names(R_combo_out[[2]])
names(R_combo_out[[1]][[1]])
names(R_combo_out[[1]][[2]])
names(R_combo_out[[1]])
names(R_combo_out[[1]][[1]][[1]])
names(R_combo_out[[1]][[1]][[2]])
str(R_combo_out)
length(R_combo_out)
length(R_combo_out[[1]])
R_combo_out[[1]][[1]]
R_combo_out[[1]][[7]]
R_combo_out[[1]][[6]]
R_combo_out[[1]][[2]]
R_combo_out[[1]][[3]]
R_combo_out[[1]][[4]]
4: total_extinctions
R_combo_out[[1]][[cascade_frequency]]
R_combo_out[[1]][[6]]
names(R_combo_out)
R_combo_out[["VAlowVAlow"]][[6]]
R_combo_out["VAlowVAlow"][[6]]
R_combo_out["VA_lowVA_low"][[6]]
R_combo_out[["VA_lowVA_low"]][[6]]
R_combo_out[["VA_lowVA_low"]][[6]]#
R_combo_out[["VA_medVA_med"]][[6]]#
R_combo_out[["VA_highVA_high"]][[6]]
as.vector(R_combo_out[["VA_lowVA_low"]][[6]])
do.call(c, R_combo_out[["VA_lowVA_low"]][[6]])
freq_VAlow <- do.call(c, R_combo_out[["VA_lowVA_low"]][[6]])#
freq_VAmed <- do.call(c, R_combo_out[["VA_medVA_med"]][[6]])#
freq_VAhigh <- do.call(c, R_combo_out[["VA_highVA_high"]][[6]])
set.seed(1)
stripchart(#
  x = list(freq_VAlow, freq_VAmed, freq_VAhigh), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 0.8,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n"#
  # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
mat_empirical
length(mat_empirical)
freq_VAhilo <- do.call(c, R_combo_out[["VA_highVA_low"]][[6]])
freq_VAhilo
stripchart(#
  x = list(freq_VAlow, freq_VAmed, freq_VAhigh, freq_VAhilo), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 0.8,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n"#
  # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
R_by_guild
stripchart(#
  x = list(freq_VAlow, freq_VAmed, freq_VAhigh, freq_VAhilo), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 0.8,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n"#
  # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
stripchart(#
  x = list(freq_VAlow, freq_VAmed, freq_VAhigh, freq_VAhilo), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 0.8,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n"#
  # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
stripchart(#
  x = list(freq_VAlow, freq_VAmed, freq_VAhigh, freq_VAhilo), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 10,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n"#
  # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
coextNumber_Vieira <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_Vieira(imatrix,ranim = ranim, rplants = rplants, targetGuild = guild, target = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
#(April 23 2014).#
#
netcascade_Vieira <- function(imatrix,ranim,rplants,deadPlants=NULL, deadAnimals=NULL, targetGuild,target,return.matrix=F){#
  #---------ARGUMENT CHECKS-----------------------------------#
  if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall")}#
  if(class(ranim)!="numeric" || class(rplants) != "numeric" || max(c(max(ranim),max(rplants)))>1 || min(c(min(ranim),min(rplants)))<0){stop("'ranim' & 'rplants' must be numeric vectors with values ranging between 0 and 1")}#
  if((targetGuild%in%c("animal","plant"))==F){stop('Invalid target guild for primary extinction. Valid targets guilds are "animal" and "plant"')}#
  if(is.numeric(target)==F){stop('Invalid value for the "target" argument. You may specify a single species by entering its row or column number or you may use a vector of relative probabilites for all species in the target guild.')}#
  if(is.null(deadAnimals)==F && class(deadAnimals)!= "integer"){stop("deadAnimals must be either NULL or an integer vector specifying the row numbers of animals considered to be extinct on the original matrix")}#
  if(is.null(deadPlants)==F && class(deadPlants)!= "integer"){stop("deadPlants must be either NULL an integer vector specifying the column numbers of plants considered to be extinct on the original matrix")}#
  if(length(ranim)!= nrow(imatrix)){stop("The length of vector'ranim' must be equal to number of rows (i.e. animal species) in 'imatrix'")}#
  if(length(rplants)!= ncol(imatrix)){stop("The length of vector'rplants' must be equal to number of columns (i.e. plant species) in 'imatrix'")}#
  #---------DEFINING SOME VARIABLES---------------------------#
  nanim <- nrow(imatrix)#
  npla <- ncol(imatrix)#
  plants <- 1:npla;#
  animals <- 1:nanim#
  plantNA <- 1:npla#
  animNA <- 1:nanim#
  plantNA[deadPlants] <- NA#
  animNA[deadAnimals] <- NA #
  degree_when_lost_plants <- c()#
  degree_when_lost_animals <- c()#
  #----------CALCULATING DEPENDENCE MATRICES-------------------#
  M <- array(0,dim=c(nanim,npla,2))#
  for(i in 1:npla){#
    M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
  } #matrix of plant dependence on each animal#
  for(i in 1:nanim){#
    M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
  } #matrix of animal dependence on each plant#
  #-----------CHOOSING TARGET SPECIES FOR PRIMARY EXTINCTION---#
  coext_animals <- c()#
  coext_plants <- c()#
  if(length(target)==1){#
    if(targetGuild=="animal"){#
      if(target %in% deadAnimals){stop('Specified target species for the primary extinction is already extinct')}#
      coext_animals <- target#
      degree_when_lost_animals <- 1 #stores the degree of the extinction event of every animal species lost during the coextinction cascade. #
    }#
    if(targetGuild=="plant"){#
      if(target %in% deadPlants){stop('Specified target species for the primary extinction is already extinct')}#
      coext_plants <- target#
      degree_when_lost_plants <- 1#
    }#
  }else{#
    nspecies <- switch(targetGuild,animal = nanim, plant = npla)#
    if(length(target)==nspecies){#
      if(targetGuild =="animal"){#
        alive <- animals[is.na(animNA)==F]#
        coext_animals <- sample(c(alive,0),1,prob = c(target[is.na(animNA)==F],0))#
        degree_when_lost_animals <- 1#
      }#
      if(targetGuild =="plant"){#
        alive <- plants[is.na(plantNA)==F]#
        coext_plants <- sample(c(alive,0),1,prob = c(target[is.na(plantNA)==F],0))#
        degree_when_lost_plants <- 1#
      }#
    }else{#
      stop('Length of "target" must be 1 (specifying a single species within the target guild) or else be equal to the number of species in the target guild (specifying probabilities of primary extinction for each species in the target guild)')#
    }#
  }#
  imatrix[coext_animals,] <- 0 #
  imatrix[,coext_plants] <- 0#
  lostanimals <- coext_animals #final list of animals which were "alive" in the original community but became extinct during this primary extinction + extinction cascade#
  lostplants <- coext_plants #
  #-------------------CASCADE LOOP---------------------------#
  equilibrium <- FALSE#
  degree <- 1#
  degree_table <- data.frame(degree,guild=factor(targetGuild,levels=c("animal","plant")),n_extinctions=1)#
  while(equilibrium == FALSE){#
    ext_animals <- coext_animals#
    ext_plants <- coext_plants#
    plantNA[ext_plants] <- NA#
    animNA[ext_animals] <- NA#
    aleft <- animals[is.na(animNA)==F]#
    pleft <- plants[is.na(plantNA)==F]#
    if(length(ext_animals)>0){#
      for(i in 1:length(ext_animals)){#
        unlucky <- rplants[pleft]*M[ext_animals[i],pleft,1] > runif(length(pleft))#
        coext_plants = c(coext_plants,pleft[unlucky])#
      }#
      coext_animals <- c()#
      coext_plants <- unique(coext_plants)#
      plantNA[coext_plants] <- NA#
      lostplants <- c(lostplants,coext_plants)#
      imatrix[,coext_plants] <- 0#
      for(i in 1:npla){#
        if(sum(imatrix[,i])==0){#
          M[,i,1] <- 0#
        }else{#
          M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
        }#
      }#
      if(length(coext_plants)>0){#
        degree <- degree + 1#
        degree_when_lost_plants <- c(degree_when_lost_plants, rep(degree,length(coext_plants)))#
        degree_table[degree,] <- data.frame(degree,"plant",length(coext_plants))#
      }#
    }else{#
      for(i in 1:length(ext_plants)){#
        unlucky <- ranim[aleft]*M[aleft,ext_plants[i],2] > runif(length(aleft))#
        coext_animals <- c(coext_animals, aleft[unlucky])#
      }#
      coext_plants = c();#
      coext_animals <- unique(coext_animals)#
      lostanimals <- c(lostanimals,coext_animals)#
      animNA[coext_animals] <- NA#
      imatrix[coext_animals,] <- 0#
      for(i in 1:nanim){#
        if(sum(imatrix[i,])==0){#
          M[i,,2] <- 0#
        }else{#
          M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
        }#
      }#
      if(length(coext_animals)>0){#
        degree <- degree + 1#
        degree_when_lost_animals <- c(degree_when_lost_animals, rep(degree,length(coext_animals)))#
        degree_table[degree,] <- data.frame(degree,"animal",length(coext_animals))  #
      }#
    }#
    equilibrium <- equilibrium + (length(coext_plants)+length(coext_animals))==0#
  }#
  #-------------------OUTPUT---------------------------#
  if(return.matrix==T){#
    return(list(interaction_matrix = imatrix, lost_animals = lostanimals, lost_plants = lostplants))  #
  }else{#
    if(length(lostanimals)>0){#
      spp_data_animals <- data.frame(lost_animal = lostanimals,degree_of_extinction=degree_when_lost_animals)#
    }else{#
      spp_data_animals <- "No animal species were lost"#
    }#
    if(length(lostplants)>0){#
      spp_data_plants <- data.frame(lost_plant = lostplants,degree_of_extinction=degree_when_lost_plants)#
    }else{#
      spp_data_plants <- "No plant species were lost"#
    }#
    return(list(cascade_data=degree_table,animal_species_data=spp_data_animals,plant_species_data=spp_data_plants))#
  }#
}
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
coextNumber_Vieira <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_Vieira(imatrix,ranim = ranim, rplants = rplants, targetGuild = guild, target = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
#coextMaxLvl performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and returns how often the extinction sequence ended in each extinction level (i.e. first level, second level, third level, etc.) #
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
coextDeg_Vieira <- function(imatrix,rlow,rup,nsims){#
  degs <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }   #
    profiles <- netcascade_Vieira(imatrix=imatrix,ranim=ranim,rplants=rplants,targetGuild=guild,target=target)#
    degs[sim] <- max(profiles[[1]]$degree)#
  }#
  return(degs)#
}
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
coextNumber_Vieira <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_Vieira(imatrix,ranim = ranim, rplants = rplants, targetGuild = guild, target = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
mat_empirical
extinction_number_Vieira <- list()
length(mat_empirical)
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}
extinction_number_Vieira
lapply(extinction_number_Vieira, function(x) sum(which(x > 1)))
lapply(extinction_number_Vieira, function(x) sum(x > 1))
do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))
Vieira_low <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.3, rup = 0.6, nsims = 100)#
}
Vieira_med <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.6, rup = 10, nsims = 100)#
}
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.6, rup = 1, nsims = 100)#
}
Vieira_high <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))
Vieira_low
Vieira_low/100
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}#
Vieira_low <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.3, rup = 0.6, nsims = 100)#
}#
Vieira_med <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.6, rup = 1, nsims = 100)#
}#
Vieira_high <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(Vieira_low, Vieira_med, Vieira_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n"#
  # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}#
Vieira_low <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.3, rup = 0.6, nsims = 100)#
}#
Vieira_med <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.6, rup = 1, nsims = 100)#
}#
Vieira_high <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(Vieira_low, Vieira_med, Vieira_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n"#
  # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(Vieira_low, Vieira_med, Vieira_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n", #
  group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
)
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(Vieira_low, Vieira_med, Vieira_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  xaxt = "n", #
  group.names = c("R{0,0.3}", "R{0.3,0.6}", "R{0.6,1}")#
)
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(Vieira_low, Vieira_med, Vieira_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  # xaxt = "n", #
  group.names = c("R{0,0.3}", "R{0.3,0.6}", "R{0.6,1}")#
)
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_JO <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_JO(imatrix,ranim = ranim, rplants = rplants, targetGuild = guild, target = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}#
JO_low <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_JO <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascadeJO(imatrix,ranim = ranim, rplants = rplants, targetGuild = guild, target = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}#
JO_low <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100
#(December 8 2015).#
#
netcascade_JO <- function(#
					imatrix, #
					R_rows, #
					R_cols, #
					unluckyGuild, #
					unluckySpecies, #
					extinct_cols=NULL, #
					extinct_rows=NULL, #
					return.matrix=FALSE#
					){#
  #---------ARGUMENT CHECKS-----------------------------------#
  if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with at least three species overall#
  	")}#
  if(class(R_rows)!="numeric" || class(R_cols) != "numeric" || max(c(max(R_rows),max(R_cols)))>1 || min(c(min(R_rows),min(R_cols)))<0){stop("#
  	'R_rows' & 'R_cols' must be numeric vectors with values ranging between 0 and 1#
  	")}#
  if(length(R_rows)!= nrow(imatrix)){stop("#
  	The length of vector'R_rows' must be equal to number of rows (i.e. species in guild) in 'imatrix'#
  	")}#
  if(length(R_cols)!= ncol(imatrix)){stop("#
  	The length of vector'R_cols' must be equal to number of columns in 'imatrix'#
  	")}#
  if((unluckyGuild%in%c("rows","cols"))==FALSE){stop('#
  	Invalid target guild for primary extinction. Valid targets guilds are "rows" and "cols"#
  	')}#
  if(is.numeric(unluckySpecies)==FALSE){stop('#
  	Invalid value for the "unluckySpecies" argument. You may specify a single species by entering its row or column number or you may use a vector of relative probabilites for all species in the unlucky guild.#
  	')}#
  if(is.null(extinct_cols)==FALSE && class(extinct_cols)!= "integer"){stop("#
  	extinct_cols must be either NULL an integer vector specifying the column numbers of species considered to be extinct on the original matrix#
  	")}#
  if(is.null(extinct_rows)==FALSE && class(extinct_rows)!= "integer"){stop("#
  	extinct_rows must be either NULL or an integer vector specifying the row numbers of species considered to be extinct on the original matrix#
  	")}#
  #---------DEFINING SOME VARIABLES---------------------------#
  nrows <- nrow(imatrix)#
  ncols <- ncol(imatrix)#
  cols <- 1:ncols#
  rows <- 1:nrows#
  colsNA <- 1:ncols#
  rowsNA <- 1:nrows#
  colsNA[extinct_cols] <- NA#
  rowsNA[extinct_rows] <- NA#
  degree_when_lost_cols <- c()#
  degree_when_lost_rows <- c()#
  #----------CALCULATING DEPENDENCE MATRICES-------------------#
  M <- array(0,dim=c(nrows,ncols,2))#
  for(i in 1:ncols){#
    M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
  } #matrix of columns' dependence on each row#
  for(i in 1:nrows){#
    M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
  } #matrix of rows' dependence on each column#
  #-----------CHOOSING TARGET SPECIES FOR PRIMARY EXTINCTION---#
  coext_rows <- c()#
  coext_cols <- c()#
  if(length(unluckySpecies)==1){#
    if(unluckyGuild=="rows"){#
      if(unluckySpecies %in% extinct_rows){stop('Specified target species for the primary extinction is already extinct')}#
      coext_rows <- unluckySpecies#
      degree_when_lost_rows <- 1 #stores the degree of the extinction event of every row lost during the coextinction cascade. #
    }#
    if(unluckyGuild=="cols"){#
      if(unluckySpecies %in% extinct_cols){stop('Specified target species for the primary extinction is already extinct')}#
      coext_cols <- unluckySpecies#
      degree_when_lost_cols <- 1#
    }#
  }else{#
    nspecies <- switch(unluckyGuild, rows = nrows, cols = ncols)#
    if(length(unluckySpecies)==nspecies){#
      if(unluckyGuild =="rows"){#
        alive <- rows[is.na(rowsNA)==FALSE]#
        coext_rows <- sample(c(alive,0),1,prob = c(unluckySpecies[is.na(rowsNA)==FALSE],0))#
        degree_when_lost_rows <- 1#
      }#
      if(unluckyGuild =="cols"){#
        alive <- cols[is.na(colsNA)==FALSE]#
        coext_cols <- sample(c(alive,0),1,prob = c(unluckySpecies[is.na(colsNA)==FALSE],0))#
        degree_when_lost_cols <- 1#
      }#
    }else{#
      stop('Length of "unluckySpecies" must be 1 (specifying a single species within the unlucky guild) or else be equal to the number of species in the unlucky guild (specifying probabilities of primary extinction for each species in the unlucky guild)')#
    }#
  }#
  imatrix[coext_rows,] <- 0 #
  imatrix[,coext_cols] <- 0#
  lost_rows <- coext_rows #final list of rows which were "alive" in the original community but became extinct during this primary extinction + extinction cascade#
  lost_cols <- coext_cols #
  #-------------------CASCADE LOOP---------------------------#
  equilibrium <- FALSE#
  degree <- 1#
  degree_table <- data.frame(degree,guild=factor(unluckyGuild,levels=c("rows","cols")),n_extinctions=1)#
  while(equilibrium == FALSE){#
    extinct_rows <- coext_rows#
    extinct_cols <- coext_cols#
    colsNA[extinct_cols] <- NA#
    rowsNA[extinct_rows] <- NA#
    remaining_rows <- rows[is.na(rowsNA) == FALSE]#
    remaining_cols <- cols[is.na(colsNA) == FALSE]#
    # If one of the rows is extinct...#
    if(length(extinct_rows)>0){#
      for(i in 1:length(extinct_rows)){#
      	# This is the first place R is used; modify accordingly, e.g.#
      	# R_cols#
      	# ...Cull a column if its value of P is greater than that of the remaining columns (drawn from uniform dist?)#
        unlucky <- R_cols[remaining_cols]*M[extinct_rows[i],remaining_cols,1] > runif(length(remaining_cols))#
        coext_cols = c(coext_cols, remaining_cols[unlucky])#
      }#
      coext_rows <- c()#
      coext_cols <- unique(coext_cols)#
      colsNA[coext_cols] <- NA#
      lost_cols <- c(lost_cols,coext_cols)#
      # remove all of that column's interactions#
      imatrix[,coext_cols] <- 0#
      # make its interaction strengths zero; recalculate interaction strengths#
      for(i in 1:ncols){#
        if(sum(imatrix[,i])==0){#
          M[,i,1] <- 0#
        }else{#
          M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
        }#
      }#
      # add a degree if there were additional columns extinct (why just 1?)#
      if(length(coext_cols)>0){#
        degree <- degree + 1#
        degree_when_lost_cols <- c(degree_when_lost_cols, rep(degree,length(coext_cols)))#
        degree_table[degree,] <- data.frame(degree,"cols",length(coext_cols))#
      }#
    }else{#
      for(i in 1:length(extinct_cols)){#
        unlucky <- R_rows[remaining_rows]*M[remaining_rows,extinct_cols[i],2] > runif(length(remaining_rows))#
        coext_rows <- c(coext_rows, remaining_rows[unlucky])#
      }#
      coext_cols = c();#
      coext_rows <- unique(coext_rows)#
      lost_rows <- c(lost_rows,coext_rows)#
      rowsNA[coext_rows] <- NA#
      imatrix[coext_rows,] <- 0#
      for(i in 1:nrows){#
        if(sum(imatrix[i,])==0){#
          M[i,,2] <- 0#
        }else{#
          M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
        }#
      }#
      if(length(coext_rows)>0){#
        degree <- degree + 1#
        degree_when_lost_rows <- c(degree_when_lost_rows, rep(degree,length(coext_rows)))#
        degree_table[degree,] <- data.frame(degree,"rows",length(coext_rows))  #
      }#
    }#
    equilibrium <- equilibrium + (length(coext_cols)+length(coext_rows))==0#
  }#
  #-------------------OUTPUT---------------------------#
  if(return.matrix==TRUE){#
    return(list(interaction_matrix = imatrix, lost_rows = lost_rows, lost_cols = lost_cols))  #
  }else{#
    if(length(lost_rows)>0){#
      spp_data_rows <- data.frame(lost_rows = lost_rows, degree_of_extinction = degree_when_lost_rows)#
    }else{#
      spp_data_rows <- "No rows were lost"#
    }#
    if(length(lost_cols)>0){#
      spp_data_cols <- data.frame(lost_col = lost_cols,degree_of_extinction=degree_when_lost_cols)#
    }else{#
      spp_data_cols <- "No columns were lost"#
    }#
    return(list(cascade_data = degree_table, rows_species_data = spp_data_rows , cols_species_data = spp_data_cols))#
  }#
}
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}#
Vieira_low <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.3, rup = 0.6, nsims = 100)#
}#
Vieira_med <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
extinction_number_Vieira <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_Vieira[[i]] <- coextNumber_Vieira(mat_empirical[[i]], rlow = 0.6, rup = 1, nsims = 100)#
}#
Vieira_high <- do.call(c, lapply(extinction_number_Vieira, function(x) sum(x > 1)))/100#
#
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(Vieira_low, Vieira_med, Vieira_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  # xaxt = "n", #
  group.names = c("R{0,0.3}", "R{0.3,0.6}", "R{0.6,1}")#
)
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}#
JO_low <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_JO <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_JO(imatrix = imatrix, R_rows = ranim, R_cols = rplants, unluckyGuild = guild, unluckySpecies = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_JO <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('rows','cols'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="rows"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_JO(imatrix = imatrix, R_rows = ranim, R_cols = rplants, unluckyGuild = guild, unluckySpecies = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}
JO_low <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0, rup = 0.3, nsims = 100)#
}#
JO_low <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100#
#
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0.3, rup = 0.6, nsims = 100)#
}#
JO_med <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100#
#
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0.6, rup = 1, nsims = 100)#
}#
JO_high <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(JO_low, JO_med, JO_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  # xaxt = "n", #
  group.names = c("R{0,0.3}", "R{0.3,0.6}", "R{0.6,1}")#
)
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_JO <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    R_rows <- rep(rvalue, nrow(imatrix))#
    R_cols <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('rows','cols'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="rows"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_JO(imatrix = imatrix, R_rows = R_rows, R_cols = R_cols, unluckyGuild = guild, unluckySpecies = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0.3, rup = 0.6, nsims = 100)#
}#
JO_med <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100#
#
extinction_number_JO <- list()#
for(i in 1:length(mat_empirical)){#
	extinction_number_JO[[i]] <- coextNumber_JO(mat_empirical[[i]], rlow = 0.6, rup = 1, nsims = 100)#
}#
JO_high <- do.call(c, lapply(extinction_number_JO, function(x) sum(x > 1)))/100#
#
set.seed(1)#
par(mar = c(5,4,1,1))#
stripchart(#
  x = list(JO_low, JO_med, JO_high), #
  vertical = TRUE,#
  method = "jitter",#
  jitter = 0.2,#
  pch = 1, col = "black", #bg = "grey",#
  cex = 1,#
  # las = 2,#
  ylab = "Cascade frequency",#
  ylim = c(0,1),#
  # xaxt = "n", #
  group.names = c("R{0,0.3}", "R{0.3,0.6}", "R{0.6,1}")#
)
boxplot(count ~ spray, data = InsectSprays, outpch = NA) #
stripchart(count ~ spray, data = InsectSprays, #
            vertical = TRUE, method = "jitter", #
            pch = 21, col = "maroon", bg = "bisque", #
            add = TRUE)
# Plot dots (a stripchart) over boxplot#
#
# source http://r.789695.n4.nabble.com/overlap-dot-plots-with-box-plots-td2134530.html#
#
boxplot(count ~ spray, data = InsectSprays, outpch = NA) #
stripchart(count ~ spray, data = InsectSprays, #
            vertical = TRUE, method = "jitter", #
            pch = 21, col = "maroon", bg = "bisque", #
            add = TRUE) #
#
# (Setting 'outpch = NA' avoids plotting outliers.)
