type = "inner")
rbeta
?rbeta
x <- seq(0, 1, length = 21)#
dbeta(x, 1, 1)#
pbeta(x, 1, 1)#
#
## Visualization, including limit cases:#
pl.beta <- function(a,b, asp = if(isLim) 1, ylim = if(isLim) c(0,1.1)) {#
  if(isLim <- a == 0 || b == 0 || a == Inf || b == Inf) {#
    eps <- 1e-10#
    x <- c(0, eps, (1:7)/16, 1/2+c(-eps,0,eps), (9:15)/16, 1-eps, 1)#
  } else {#
    x <- seq(0, 1, length = 1025)#
  }#
  fx <- cbind(dbeta(x, a,b), pbeta(x, a,b), qbeta(x, a,b))#
  f <- fx; f[fx == Inf] <- 1e100#
  matplot(x, f, ylab="", type="l", ylim=ylim, asp=asp,#
          main = sprintf("[dpq]beta(x, a=%g, b=%g)", a,b))#
  abline(0,1,     col="gray", lty=3)#
  abline(h = 0:1, col="gray", lty=3)#
  legend("top", paste0(c("d","p","q"), "beta(x, a,b)"),#
         col=1:3, lty=1:3, bty = "n")#
  invisible(cbind(x, fx))#
}#
pl.beta(3,1)
pl.beta(2, 4)
pl.beta(3, 7)
pl.beta(3, 7, asp=1)
pl.beta(0, 0)   ## point masses at  {0, 1}
pl.beta(0, 2)   ## point mass at 0 ; the same as
pl.beta(3,1)
stop("")
stop("
'imatrix' must be an object
")
stop("
must be a matrix
")
stop(
stuff is wrong
stop(
stuff is wrong
test_matrix <- read.table("/Users/threeprime/Dropbox/NIMBioS_END/extinctions/Data/nets_emp/DIHI.txt")
test_matrix
(test_matrix)
imatrix <- test_matrix
ranim <- runif(nrow(imatrix))
ranim
plot(ranim)
rplants <- runif(ncol(imatrix))
deadPlants <- NULL
deadPlants
deadAnimals <- NULL
targetGuild <- "plant"
target <- 1
bigmat <- rep(imatrix, 1000)
load("/Users/threeprime/Dropbox/Compute/R/general/lsos.RData")
lsos()
length(bigmat)
target
if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall#
  	")}
class(imatrix)
as.matrix(imatrix)
imatrix <- as.matrix(imatrix)
imatrix
if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall#
  	")}
if(class(ranim)!="numeric" || class(rplants) != "numeric" || max(c(max(ranim),max(rplants)))>1 || min(c(min(ranim),min(rplants)))<0){stop("#
  	'ranim' & 'rplants' must be numeric vectors with values ranging between 0 and 1#
  	")}
if((targetGuild%in%c("animal","plant"))==FALSE){stop('#
  	Invalid target guild for primary extinction. Valid targets guilds are "animal" and "plant"#
  	')}
if(is.numeric(target)==FALSE){stop('#
  	Invalid value for the "target" argument. You may specify a single species by entering its row or column number or you may use a vector of relative probabilites for all species in the target guild.#
  	')}
if(is.null(deadAnimals)==FALSE && class(deadAnimals)!= "integer"){stop("#
  	deadAnimals must be either NULL or an integer vector specifying the row numbers of animals considered to be extinct on the original matrix#
  	")}
if(is.null(deadPlants)==FALSE && class(deadPlants)!= "integer"){stop("#
  	deadPlants must be either NULL an integer vector specifying the column numbers of plants considered to be extinct on the original matrix#
  	")}
if(length(ranim)!= nrow(imatrix)){stop("#
  	The length of vector'ranim' must be equal to number of rows (i.e. animal species) in 'imatrix'#
  	")}
if(length(rplants)!= ncol(imatrix)){stop("#
  	The length of vector'rplants' must be equal to number of columns (i.e. plant species) in 'imatrix'#
  	")}
nanim <- nrow(imatrix)#
  npla <- ncol(imatrix)#
  plants <- 1:npla#
  animals <- 1:nanim#
  plantNA <- 1:npla#
  animNA <- 1:nanim#
  plantNA[deadPlants] <- NA#
  animNA[deadAnimals] <- NA
animNA
degree_when_lost_plants <- c()#
  degree_when_lost_animals <- c()
M <- array(0,dim=c(nanim,npla,2))
M
dim(imatrix)
sum(imatrix[,1])
imatrix[,1]
for(i in 1:npla){#
    M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
  } #matrix of plant dependence on each animal
for(i in 1:nanim){#
    M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
  } #matrix of animal dependence on each plant
targetGuild
target
coext_animals <- c()#
  coext_plants <- c()
if(length(target)==1){#
    if(targetGuild=="animal"){#
      if(target %in% deadAnimals){stop('Specified target species for the primary extinction is already extinct')}#
      coext_animals <- target#
      degree_when_lost_animals <- 1 #stores the degree of the extinction event of every animal species lost during the coextinction cascade. #
    }#
    if(targetGuild=="plant"){#
      if(target %in% deadPlants){stop('Specified target species for the primary extinction is already extinct')}#
      coext_plants <- target#
      degree_when_lost_plants <- 1#
    }
}else{#
    nspecies <- switch(targetGuild,animal = nanim, plant = npla)#
    if(length(target)==nspecies){#
      if(targetGuild =="animal"){#
        alive <- animals[is.na(animNA)==F]#
        coext_animals <- sample(c(alive,0),1,prob = c(target[is.na(animNA)==F],0))#
        degree_when_lost_animals <- 1#
      }#
      if(targetGuild =="plant"){#
        alive <- plants[is.na(plantNA)==F]#
        coext_plants <- sample(c(alive,0),1,prob = c(target[is.na(plantNA)==F],0))#
        degree_when_lost_plants <- 1#
      }#
    }else{#
      stop('Length of "target" must be 1 (specifying a single species within the target guild) or else be equal to the number of species in the target guild (specifying probabilities of primary extinction for each species in the target guild)')#
    }#
  }
coext_plants
coext_animals
coext_plants
degree_when_lost_plants
M
dim(M)
coext_animals
coext_plants
imatrix[coext_animals,] <- 0 #
  imatrix[,coext_plants] <- 0
lostanimals <- coext_animals #final list of animals which were "alive" in the original community but became extinct during this primary extinction + extinction cascade#
  lostplants <- coext_plants
coext_animals
coext_plants
rows
rows()
cols()
cols
nrows
ncols
stuff <- "things"
list(stuff = stuff)
?switch
col
row
column
row
switch("plant", animal = 4, plant = 3)
switch("plant", animal = 4, plant = 2)
switch("plant", animal = 4, plant = 1)
switch("plant", animal = 4, plan2t = 5)
hsb2 <- read.table('http://www.ats.ucla.edu/stat/r/faq/hsb2.csv', header=T, sep=",")
hsb2[1:10,]
l <- reshape(hsb2, #
  varying = c("read", "write", "math", "science", "socst"), #
  v.names = "score",#
  timevar = "subj", #
  times = c("read", "write", "math", "science", "socst"), #
  new.row.names = 1:1000,#
  direction = "long")
l
load("/Users/threeprime/Dropbox/Compute/R/general/lsos.RData")
data_dir <- file.path("..", "Data")#
fig_dir <- file.path("..", "Figures")#
source("functions/netcascade_JO.R")#
source("functions/extinction_cascader.R")#
#
beta.par <- matrix(c(0.1, 1, 0.5, 1, 1, 1, 3, 3, 4, 0.1, 0.2, 0.2), byrow = TRUE, ncol = 2)#
rownames(beta.par)=c("exp","power","unif","normal","left", "bimod")#
R_options <- c("VA_low", "VA_med", "VA_high", rownames(beta.par))#
#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
#
# load all networks in that directory#
emp_nets<-dir(path = emp_net_path) #Plant-pollinator weighted nets#
#
mat_empirical <- list()#
#
for(p in 1:length(emp_nets)){#
	mat_empirical[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_nets[p])))#
}#
mat_empirical[[4]] <- NULL#
#
R_by_guild <- expand.grid(R_options, R_options)#
############################################################
#------------- RUN THE SIMULATIONS#
############################################################
N_iterations <- 100#
#
R_combo_out <- list()#
#
for(Rcombo in 1:nrow(R_by_guild)){#
	current_Rrows <- as.character(R_by_guild[Rcombo,1])#
	current_Rcols <- as.character(R_by_guild[Rcombo,2])#
	# DO THE SIMULATIONS ON EACH NETWORK#
	stored_events <- list()#
	just_extinctions <- list()#
	extinctions_by_guild <- list()#
	total_extinctions <- list()#
	total_cascades <- list()#
	cascade_frequency <- list()#
	for(i in 1:length(mat_empirical)){#
		mat <- mat_empirical[[i]]#
		if(min(c(rowSums(mat), colSums(mat))) == 0){#
		stop("Hey, you have a species in your network that does not interact with any other species. The following functions will get stuck.")}#
		m<-nrow(mat)#
		n<-ncol(mat)#
		stored_events[[i]] <- extinction_cascader(imatrix = mat, R_row = current_Rrows, R_col = current_Rcols, nsims = N_iterations)#
		just_extinctions[[i]] <- lapply(stored_events[[i]], "[", c("lost_cols", "lost_rows"))#
		extinctions_by_guild[[i]] <- do.call(rbind, lapply(just_extinctions[[i]], lengths))#
		total_extinctions[[i]] <- rowSums(extinctions_by_guild[[i]])#
		total_cascades[[i]] <- sum(total_extinctions[[i]] > 1)#
		cascade_frequency[[i]] <- total_cascades[[i]]/length(stored_events[[i]])#
	}#
#
	R_combo_out[[Rcombo]] <- list(stored_events, just_extinctions, extinctions_by_guild, total_extinctions, total_cascades, cascade_frequency)#
#
}#
#
lsos()
#coextMaxLvl performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and returns how often the extinction sequence ended in each extinction level (i.e. first level, second level, third level, etc.) #
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
coextDeg_Vieira <- function(imatrix,rlow,rup,nsims){#
  degs <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }   #
    profiles <- netcascade_Vieira(imatrix=imatrix,ranim=ranim,rplants=rplants,targetGuild=guild,target=target)#
    degs[sim] <- max(profiles[[1]]$degree)#
  }#
  return(degs)#
}
#(April 23 2014).#
#
netcascade_Vieira <- function(imatrix,ranim,rplants,deadPlants=NULL, deadAnimals=NULL, targetGuild,target,return.matrix=F){#
  #---------ARGUMENT CHECKS-----------------------------------#
  if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("'imatrix' must be an object of class 'matrix', with animal species on rows, plant species on columns and at least three species overall")}#
  if(class(ranim)!="numeric" || class(rplants) != "numeric" || max(c(max(ranim),max(rplants)))>1 || min(c(min(ranim),min(rplants)))<0){stop("'ranim' & 'rplants' must be numeric vectors with values ranging between 0 and 1")}#
  if((targetGuild%in%c("animal","plant"))==F){stop('Invalid target guild for primary extinction. Valid targets guilds are "animal" and "plant"')}#
  if(is.numeric(target)==F){stop('Invalid value for the "target" argument. You may specify a single species by entering its row or column number or you may use a vector of relative probabilites for all species in the target guild.')}#
  if(is.null(deadAnimals)==F && class(deadAnimals)!= "integer"){stop("deadAnimals must be either NULL or an integer vector specifying the row numbers of animals considered to be extinct on the original matrix")}#
  if(is.null(deadPlants)==F && class(deadPlants)!= "integer"){stop("deadPlants must be either NULL an integer vector specifying the column numbers of plants considered to be extinct on the original matrix")}#
  if(length(ranim)!= nrow(imatrix)){stop("The length of vector'ranim' must be equal to number of rows (i.e. animal species) in 'imatrix'")}#
  if(length(rplants)!= ncol(imatrix)){stop("The length of vector'rplants' must be equal to number of columns (i.e. plant species) in 'imatrix'")}#
  #---------DEFINING SOME VARIABLES---------------------------#
  nanim <- nrow(imatrix)#
  npla <- ncol(imatrix)#
  plants <- 1:npla;#
  animals <- 1:nanim#
  plantNA <- 1:npla#
  animNA <- 1:nanim#
  plantNA[deadPlants] <- NA#
  animNA[deadAnimals] <- NA #
  degree_when_lost_plants <- c()#
  degree_when_lost_animals <- c()#
  #----------CALCULATING DEPENDENCE MATRICES-------------------#
  M <- array(0,dim=c(nanim,npla,2))#
  for(i in 1:npla){#
    M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
  } #matrix of plant dependence on each animal#
  for(i in 1:nanim){#
    M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
  } #matrix of animal dependence on each plant#
  #-----------CHOOSING TARGET SPECIES FOR PRIMARY EXTINCTION---#
  coext_animals <- c()#
  coext_plants <- c()#
  if(length(target)==1){#
    if(targetGuild=="animal"){#
      if(target %in% deadAnimals){stop('Specified target species for the primary extinction is already extinct')}#
      coext_animals <- target#
      degree_when_lost_animals <- 1 #stores the degree of the extinction event of every animal species lost during the coextinction cascade. #
    }#
    if(targetGuild=="plant"){#
      if(target %in% deadPlants){stop('Specified target species for the primary extinction is already extinct')}#
      coext_plants <- target#
      degree_when_lost_plants <- 1#
    }#
  }else{#
    nspecies <- switch(targetGuild,animal = nanim, plant = npla)#
    if(length(target)==nspecies){#
      if(targetGuild =="animal"){#
        alive <- animals[is.na(animNA)==F]#
        coext_animals <- sample(c(alive,0),1,prob = c(target[is.na(animNA)==F],0))#
        degree_when_lost_animals <- 1#
      }#
      if(targetGuild =="plant"){#
        alive <- plants[is.na(plantNA)==F]#
        coext_plants <- sample(c(alive,0),1,prob = c(target[is.na(plantNA)==F],0))#
        degree_when_lost_plants <- 1#
      }#
    }else{#
      stop('Length of "target" must be 1 (specifying a single species within the target guild) or else be equal to the number of species in the target guild (specifying probabilities of primary extinction for each species in the target guild)')#
    }#
  }#
  imatrix[coext_animals,] <- 0 #
  imatrix[,coext_plants] <- 0#
  lostanimals <- coext_animals #final list of animals which were "alive" in the original community but became extinct during this primary extinction + extinction cascade#
  lostplants <- coext_plants #
  #-------------------CASCADE LOOP---------------------------#
  equilibrium <- FALSE#
  degree <- 1#
  degree_table <- data.frame(degree,guild=factor(targetGuild,levels=c("animal","plant")),n_extinctions=1)#
  while(equilibrium == FALSE){#
    ext_animals <- coext_animals#
    ext_plants <- coext_plants#
    plantNA[ext_plants] <- NA#
    animNA[ext_animals] <- NA#
    aleft <- animals[is.na(animNA)==F]#
    pleft <- plants[is.na(plantNA)==F]#
    if(length(ext_animals)>0){#
      for(i in 1:length(ext_animals)){#
        unlucky <- rplants[pleft]*M[ext_animals[i],pleft,1] > runif(length(pleft))#
        coext_plants = c(coext_plants,pleft[unlucky])#
      }#
      coext_animals <- c()#
      coext_plants <- unique(coext_plants)#
      plantNA[coext_plants] <- NA#
      lostplants <- c(lostplants,coext_plants)#
      imatrix[,coext_plants] <- 0#
      for(i in 1:npla){#
        if(sum(imatrix[,i])==0){#
          M[,i,1] <- 0#
        }else{#
          M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
        }#
      }#
      if(length(coext_plants)>0){#
        degree <- degree + 1#
        degree_when_lost_plants <- c(degree_when_lost_plants, rep(degree,length(coext_plants)))#
        degree_table[degree,] <- data.frame(degree,"plant",length(coext_plants))#
      }#
    }else{#
      for(i in 1:length(ext_plants)){#
        unlucky <- ranim[aleft]*M[aleft,ext_plants[i],2] > runif(length(aleft))#
        coext_animals <- c(coext_animals, aleft[unlucky])#
      }#
      coext_plants = c();#
      coext_animals <- unique(coext_animals)#
      lostanimals <- c(lostanimals,coext_animals)#
      animNA[coext_animals] <- NA#
      imatrix[coext_animals,] <- 0#
      for(i in 1:nanim){#
        if(sum(imatrix[i,])==0){#
          M[i,,2] <- 0#
        }else{#
          M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
        }#
      }#
      if(length(coext_animals)>0){#
        degree <- degree + 1#
        degree_when_lost_animals <- c(degree_when_lost_animals, rep(degree,length(coext_animals)))#
        degree_table[degree,] <- data.frame(degree,"animal",length(coext_animals))  #
      }#
    }#
    equilibrium <- equilibrium + (length(coext_plants)+length(coext_animals))==0#
  }#
  #-------------------OUTPUT---------------------------#
  if(return.matrix==T){#
    return(list(interaction_matrix = imatrix, lost_animals = lostanimals, lost_plants = lostplants))  #
  }else{#
    if(length(lostanimals)>0){#
      spp_data_animals <- data.frame(lost_animal = lostanimals,degree_of_extinction=degree_when_lost_animals)#
    }else{#
      spp_data_animals <- "No animal species were lost"#
    }#
    if(length(lostplants)>0){#
      spp_data_plants <- data.frame(lost_plant = lostplants,degree_of_extinction=degree_when_lost_plants)#
    }else{#
      spp_data_plants <- "No plant species were lost"#
    }#
    return(list(cascade_data=degree_table,animal_species_data=spp_data_animals,plant_species_data=spp_data_plants))#
  }#
}
ls()
load("/Users/threeprime/Dropbox/Compute/R/general/lsos.RData")
lsos
.ls.objects(..., order.by="Size", decreasing=TRUE, head=TRUE, n=n)
# source http://stackoverflow.com/questions/1358003/tricks-to-manage-the-available-memory-in-an-r-session#
#
# improved list of objects#
.ls.objects <- function (pos = 1, pattern, order.by,#
                        decreasing=FALSE, head=FALSE, n=5) {#
    napply <- function(names, fn) sapply(names, function(x)#
                                         fn(get(x, pos = pos)))#
    names <- ls(pos = pos, pattern = pattern)#
    obj.class <- napply(names, function(x) as.character(class(x))[1])#
    obj.mode <- napply(names, mode)#
    obj.type <- ifelse(is.na(obj.class), obj.mode, obj.class)#
    obj.prettysize <- napply(names, function(x) {#
                           capture.output(format(utils::object.size(x), units = "auto")) })#
    obj.size <- napply(names, object.size)#
    obj.dim <- t(napply(names, function(x)#
                        as.numeric(dim(x))[1:2]))#
    vec <- is.na(obj.dim)[, 1] & (obj.type != "function")#
    obj.dim[vec, 1] <- napply(names, length)[vec]#
    out <- data.frame(obj.type, obj.size, obj.prettysize, obj.dim)#
    names(out) <- c("Type", "Size", "PrettySize", "Rows", "Columns")#
    if (!missing(order.by))#
        out <- out[order(out[[order.by]], decreasing=decreasing), ]#
    if (head)#
        out <- head(out, n)#
    out#
}#
#
# shorthand#
lsos <- function(..., n=10) {#
    .ls.objects(..., order.by="Size", decreasing=TRUE, head=TRUE, n=n)#
}
ls()
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
coextNumber_Vieira <- function(imatrix,rlow,rup,nsims){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    rvalue <- runif(1,rlow,rup)#
    ranim <- rep(rvalue, nrow(imatrix))#
    rplants <- rep(rvalue, ncol(imatrix))#
    guild <- sample(c('animal','plant'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix))#
    }else{#
      target <- rep(1,ncol(imatrix))#
    }    #
    sim_results <- netcascade_Vieira(imatrix,ranim = ranim, rplants = rplants, targetGuild = guild, target = target)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
ls()
#(December 8 2015).#
#
netcascade_JO <- function(#
					imatrix, #
					R_rows, #
					R_cols, #
					unluckyGuild, #
					unluckySpecies, #
					extinct_cols=NULL, #
					extinct_rows=NULL, #
					return.matrix=FALSE#
					){#
  #---------ARGUMENT CHECKS-----------------------------------#
  if(class(imatrix)!="matrix" || (nrow(imatrix)+ncol(imatrix))<3){stop("#
  	'imatrix' must be an object of class 'matrix', with at least three species overall#
  	")}#
  if(class(R_rows)!="numeric" || class(R_cols) != "numeric" || max(c(max(R_rows),max(R_cols)))>1 || min(c(min(R_rows),min(R_cols)))<0){stop("#
  	'R_rows' & 'R_cols' must be numeric vectors with values ranging between 0 and 1#
  	")}#
  if(length(R_rows)!= nrow(imatrix)){stop("#
  	The length of vector'R_rows' must be equal to number of rows (i.e. species in guild) in 'imatrix'#
  	")}#
  if(length(R_cols)!= ncol(imatrix)){stop("#
  	The length of vector'R_cols' must be equal to number of columns in 'imatrix'#
  	")}#
  if((unluckyGuild%in%c("rows","cols"))==FALSE){stop('#
  	Invalid target guild for primary extinction. Valid targets guilds are "rows" and "cols"#
  	')}#
  if(is.numeric(unluckySpecies)==FALSE){stop('#
  	Invalid value for the "unluckySpecies" argument. You may specify a single species by entering its row or column number or you may use a vector of relative probabilites for all species in the unlucky guild.#
  	')}#
  if(is.null(extinct_cols)==FALSE && class(extinct_cols)!= "integer"){stop("#
  	extinct_cols must be either NULL an integer vector specifying the column numbers of species considered to be extinct on the original matrix#
  	")}#
  if(is.null(extinct_rows)==FALSE && class(extinct_rows)!= "integer"){stop("#
  	extinct_rows must be either NULL or an integer vector specifying the row numbers of species considered to be extinct on the original matrix#
  	")}#
  #---------DEFINING SOME VARIABLES---------------------------#
  nrows <- nrow(imatrix)#
  ncols <- ncol(imatrix)#
  cols <- 1:ncols#
  rows <- 1:nrows#
  colsNA <- 1:ncols#
  rowsNA <- 1:nrows#
  colsNA[extinct_cols] <- NA#
  rowsNA[extinct_rows] <- NA#
  degree_when_lost_cols <- c()#
  degree_when_lost_rows <- c()#
  #----------CALCULATING DEPENDENCE MATRICES-------------------#
  M <- array(0,dim=c(nrows,ncols,2))#
  for(i in 1:ncols){#
    M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
  } #matrix of columns' dependence on each row#
  for(i in 1:nrows){#
    M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
  } #matrix of rows' dependence on each column#
  #-----------CHOOSING TARGET SPECIES FOR PRIMARY EXTINCTION---#
  coext_rows <- c()#
  coext_cols <- c()#
  if(length(unluckySpecies)==1){#
    if(unluckyGuild=="rows"){#
      if(unluckySpecies %in% extinct_rows){stop('Specified target species for the primary extinction is already extinct')}#
      coext_rows <- unluckySpecies#
      degree_when_lost_rows <- 1 #stores the degree of the extinction event of every row lost during the coextinction cascade. #
    }#
    if(unluckyGuild=="cols"){#
      if(unluckySpecies %in% extinct_cols){stop('Specified target species for the primary extinction is already extinct')}#
      coext_cols <- unluckySpecies#
      degree_when_lost_cols <- 1#
    }#
  }else{#
    nspecies <- switch(unluckyGuild, rows = nrows, cols = ncols)#
    if(length(unluckySpecies)==nspecies){#
      if(unluckyGuild =="rows"){#
        alive <- rows[is.na(rowsNA)==FALSE]#
        coext_rows <- sample(c(alive,0),1,prob = c(unluckySpecies[is.na(rowsNA)==FALSE],0))#
        degree_when_lost_rows <- 1#
      }#
      if(unluckyGuild =="cols"){#
        alive <- cols[is.na(colsNA)==FALSE]#
        coext_cols <- sample(c(alive,0),1,prob = c(unluckySpecies[is.na(colsNA)==FALSE],0))#
        degree_when_lost_cols <- 1#
      }#
    }else{#
      stop('Length of "unluckySpecies" must be 1 (specifying a single species within the unlucky guild) or else be equal to the number of species in the unlucky guild (specifying probabilities of primary extinction for each species in the unlucky guild)')#
    }#
  }#
  imatrix[coext_rows,] <- 0 #
  imatrix[,coext_cols] <- 0#
  lost_rows <- coext_rows #final list of rows which were "alive" in the original community but became extinct during this primary extinction + extinction cascade#
  lost_cols <- coext_cols #
  #-------------------CASCADE LOOP---------------------------#
  equilibrium <- FALSE#
  degree <- 1#
  degree_table <- data.frame(degree,guild=factor(unluckyGuild,levels=c("rows","cols")),n_extinctions=1)#
  while(equilibrium == FALSE){#
    extinct_rows <- coext_rows#
    extinct_cols <- coext_cols#
    colsNA[extinct_cols] <- NA#
    rowsNA[extinct_rows] <- NA#
    remaining_rows <- rows[is.na(rowsNA) == FALSE]#
    remaining_cols <- cols[is.na(colsNA) == FALSE]#
    # If one of the rows is extinct...#
    if(length(extinct_rows)>0){#
      for(i in 1:length(extinct_rows)){#
      	# This is the first place R is used; modify accordingly, e.g.#
      	# R_cols#
      	# ...Cull a column if its value of P is greater than that of the remaining columns (drawn from uniform dist?)#
        unlucky <- R_cols[remaining_cols]*M[extinct_rows[i],remaining_cols,1] > runif(length(remaining_cols))#
        coext_cols = c(coext_cols, remaining_cols[unlucky])#
      }#
      coext_rows <- c()#
      coext_cols <- unique(coext_cols)#
      colsNA[coext_cols] <- NA#
      lost_cols <- c(lost_cols,coext_cols)#
      # remove all of that column's interactions#
      imatrix[,coext_cols] <- 0#
      # make its interaction strengths zero; recalculate interaction strengths#
      for(i in 1:ncols){#
        if(sum(imatrix[,i])==0){#
          M[,i,1] <- 0#
        }else{#
          M[,i,1] <- imatrix[,i]/sum(imatrix[,i])#
        }#
      }#
      # add a degree if there were additional columns extinct (why just 1?)#
      if(length(coext_cols)>0){#
        degree <- degree + 1#
        degree_when_lost_cols <- c(degree_when_lost_cols, rep(degree,length(coext_cols)))#
        degree_table[degree,] <- data.frame(degree,"cols",length(coext_cols))#
      }#
    }else{#
      for(i in 1:length(extinct_cols)){#
        unlucky <- R_rows[remaining_rows]*M[remaining_rows,extinct_cols[i],2] > runif(length(remaining_rows))#
        coext_rows <- c(coext_rows, remaining_rows[unlucky])#
      }#
      coext_cols = c();#
      coext_rows <- unique(coext_rows)#
      lost_rows <- c(lost_rows,coext_rows)#
      rowsNA[coext_rows] <- NA#
      imatrix[coext_rows,] <- 0#
      for(i in 1:nrows){#
        if(sum(imatrix[i,])==0){#
          M[i,,2] <- 0#
        }else{#
          M[i,,2] <- imatrix[i,]/sum(imatrix[i,])#
        }#
      }#
      if(length(coext_rows)>0){#
        degree <- degree + 1#
        degree_when_lost_rows <- c(degree_when_lost_rows, rep(degree,length(coext_rows)))#
        degree_table[degree,] <- data.frame(degree,"rows",length(coext_rows))  #
      }#
    }#
    equilibrium <- equilibrium + (length(coext_cols)+length(coext_rows))==0#
  }#
  #-------------------OUTPUT---------------------------#
  if(return.matrix==TRUE){#
    return(list(interaction_matrix = imatrix, lost_rows = lost_rows, lost_cols = lost_cols))  #
  }else{#
    if(length(lost_rows)>0){#
      spp_data_rows <- data.frame(lost_rows = lost_rows, degree_of_extinction = degree_when_lost_rows)#
    }else{#
      spp_data_rows <- "No rows were lost"#
    }#
    if(length(lost_cols)>0){#
      spp_data_cols <- data.frame(lost_col = lost_cols,degree_of_extinction=degree_when_lost_cols)#
    }else{#
      spp_data_cols <- "No columns were lost"#
    }#
    return(list(cascade_data = degree_table, rows_species_data = spp_data_rows , cols_species_data = spp_data_cols))#
  }#
}
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_beta <- function(imatrix, nsims, beta_par1_T1 = 1, beta_par2_T1 = 1, beta_par1_T2 = 1, beta_par2_T2 = 1){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    R_rows <- rbeta(n = nrow(imatrix), shape1 = beta_par1_T1, shape2 = beta_par2_T1)#
    R_cols <- rbeta(n = ncol(imatrix), shape1 = beta_par1_T2, shape2 = beta_par2_T2)#
    guild <- sample(#
    				x = c('rows','cols'), #
    				size = 1, #
    				replace = FALSE, #
    				prob = c(nrow(imatrix), ncol(imatrix))#
    				)#
    if(guild=="rows"){#
      target <- rep(1,nrow(imatrix)) #same probability of primary extinction for all spp#
    }else{#
      target <- rep(1,ncol(imatrix)) #same probability of primary extinction for all spp#
    }    #
    sim_results <- netcascade_JO(#
    								imatrix = imatrix, #
    								R_rows = R_rows, #
    								R_cols = R_cols, #
    								unluckyGuild = guild, #
    								unluckySpecies = target, #
								return.matrix=FALSE#
    								)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_beta <- function(imatrix, nsims, beta_par1_T1 = 1, beta_par2_T1 = 1, beta_par1_T2 = 1, beta_par2_T2 = 1){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    R_rows <- rbeta(n = nrow(imatrix), shape1 = beta_par1_T1, shape2 = beta_par2_T1)#
    R_cols <- rbeta(n = ncol(imatrix), shape1 = beta_par1_T2, shape2 = beta_par2_T2)#
    guild <- sample(#
    				x = c('rows','cols'), #
    				size = 1, #
    				replace = FALSE, #
    				prob = c(nrow(imatrix), ncol(imatrix))#
    				)#
    if(guild=="rows"){#
      target <- rep(1,nrow(imatrix)) #same probability of primary extinction for all spp#
    }else{#
      target <- rep(1,ncol(imatrix)) #same probability of primary extinction for all spp#
    }#
    sim_results <- netcascade_JO(#
    								imatrix = imatrix, #
    								R_rows = R_rows, #
    								R_cols = R_cols, #
    								unluckyGuild = guild, #
    								unluckySpecies = target, #
								return.matrix=FALSE#
    								)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
# Modified from original function 'coextDeg' from Vieira and Almeida-Neto 2014 ECOLET#
#
# performs simulations (n = nsims) of the subsequent extinctions following from a primary extinction event in an interaction matrix (imatrix)#
# returns how often the extinction sequence ended in each extinction level (i.e. first level, second level, third level, etc.) #
# primary extinctions in each trophic level (e.g. T1 and T2) are drawn from a beta distribution with two shape parameters for each trophic level (beta_par1_T1, beta_par2_T1, beta_par1_T2, beta_par2_T2)#
coextDeg_beta <- function(imatrix, nsims, beta_par1_T1 = 1, beta_par2_T1 = 1,beta_par1_T2 = 1, beta_par2_T2 = 1){#
  degs <- c()#
  for(sim in 1:nsims){#
    R_rows <- rbeta(n = nrow(imatrix), shape1 = beta_par1_T1, shape2 = beta_par2_T1)#
    R_cols <- rbeta(n = ncol(imatrix), shape1 = beta_par1_T2, shape2 = beta_par2_T2)#
    guild <- sample(c('rows','cols'),1,F,c(nrow(imatrix),ncol(imatrix)))#
    if(guild=="animal"){#
      target <- rep(1,nrow(imatrix)) #same probability of primary extinction for all spp#
    }else{#
      target <- rep(1,ncol(imatrix)) #same probability of primary extinction for all spp#
    }#
    profiles <- netcascade_JO(#
							imatrix = imatrix, #
							R_rows = R_rows, #
							R_cols = R_cols, #
							unluckyGuild = guild, #
							unluckySpecies = target, #
							return.matrix=FALSE#
							)#
    degs[sim] <- max(profiles[[1]]$degree)#
  }#
  return(degs)#
}#
# GRAVEYARD:#
   	# sample R values from a distribution set by user#
   	# dist_options <- c("normal", "exponential", "uniform")#
   	# TODO add a warning later#
   	# if(!(dist %in% dist_options))#
    		# stop("argument 'dist' must be one of the following: ", dist_options)#
    	# if(distr == "normal"){    		#
    		# dist_call <- rnorm    		#
    	# } else if(distr == "exponential"){    		#
    		# dist_call <- rexp#
    	# } else if(distr == "uniform"){    		#
    		# dist_call <- runif#
    	# }
#coextNumber performs simulations (n = nsims) of a single episode of primary extinction and its possible associated coextinction cascade and creates a frequency distribution for the total number of extinctions for each episode.#
#primary extinctions are uniform random among both groups.'r' is sampled from a interval (rlow, rup)#
#
coextNumber_beta <- function(imatrix, nsims, beta_par1_T1 = 1, beta_par2_T1 = 1, beta_par1_T2 = 1, beta_par2_T2 = 1){#
  ext_counts <- c()#
  for(sim in 1:nsims){#
    R_rows <- rbeta(n = nrow(imatrix), shape1 = beta_par1_T1, shape2 = beta_par2_T1)#
    R_cols <- rbeta(n = ncol(imatrix), shape1 = beta_par1_T2, shape2 = beta_par2_T2)#
    guild <- sample(#
    				x = c('rows','cols'), #
    				size = 1, #
    				replace = FALSE, #
    				prob = c(nrow(imatrix), ncol(imatrix))#
    				)#
    if(guild=="rows"){#
      target <- rep(1,nrow(imatrix)) #same probability of primary extinction for all spp#
    }else{#
      target <- rep(1,ncol(imatrix)) #same probability of primary extinction for all spp#
    }#
    sim_results <- netcascade_JO(#
    								imatrix = imatrix, #
    								R_rows = R_rows, #
    								R_cols = R_cols, #
    								unluckyGuild = guild, #
    								unluckySpecies = target, #
								return.matrix=FALSE#
    								)#
    ext_counts[sim] <- sum(sim_results[[1]]$n_extinctions)#
  }#
  return(ext_counts)#
}
beta.par <- matrix(c(0.1, 1, 0.5, 1, 1, 1, 3, 3, 4, 0.1, 0.2, 0.2), byrow = TRUE, ncol = 2)#
rownames(beta.par)=c("exp","power","unif","normal","left", "bimod")#
R_options <- c("VA_low", "VA_med", "VA_high", rownames(beta.par))
beta.bar
beta.par
setwd("/Users/threeprime/Dropbox/NIMBioS_END/extinctions/Analysis")
# point to the data directory#
data_dir <- file.path("..", "Data")#
#
# point to the figure directory to write figures#
fig_dir <- file.path("..", "Figures")#
#
# load the functions#
sapply(list.files(pattern="[.]R$", path="functions/", full.names=TRUE), source)#
# source("functions/netcascade_JO.R")#
# source("functions/extinction_cascader.R")#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
# load all networks in that directory#
emp_net_files <- dir(path = emp_net_path) #Plant-pollinator weighted nets#
emp_nets <- list()#
for(p in 1:length(emp_net_files)){#
	emp_nets[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_net_files[p])))#
}#
# NCEAS IWDB pollination networks#
poll_net_path <- file.path(data_dir, "NCEAS_text_files/plant_pollinator")#
# skip "kevan_f.txt"#
poll_net_files <- dir(path = poll_net_path)#
poll_net_files <- poll_net_files[!poll_net_files == "kevan_f.txt"]#
poll_nets <- list()#
for(p in 1:length(poll_net_files)){#
	print(p)#
	poll_nets[[p]] <- as.matrix(read.table(file.path(poll_net_path, poll_net_files[p])))#
}#
#
# NCEAS IWDB seed disperser networks#
seed_net_path <- file.path(data_dir, "NCEAS_text_files/seed_disperser")#
seed_net_files <- dir(path = seed_net_path) #Plant-pollinator weighted nets#
seed_nets <- list()#
for(p in 1:length(seed_net_files)){#
	seed_nets[[p]] <- as.matrix(read.table(file.path(seed_net_path, seed_net_files[p])))#
}
mat_empirical <- poll_nets#
mat_empirical <- c(poll_nets, seed_nets)
mat_empirical <- mat_empirical[which(sapply(mat_empirical, is.numeric))]
length(mat_empirical) # 32
test_matrix <- matrix(#
			data = round(rnorm(n = 24, mean = 20, sd = 5)), #
			nrow = 4#
)#
# imatrix <- MAT#
# R_rows <- runif(n = nrow(MAT))#
# R_cols <- runif(n = ncol(MAT))#
# unluckyGuild <- "rows"#
# unluckySpecies <- 2#
# extinct_cols=NULL #
# extinct_rows=NULL#
# return.matrix=FALSE
test_matrix
rowSums(test_matrix)
prune_absent <- function(this_mat){#
	this_mat[which(rowSums(this_mat) == 0) , ] <- NULL#
	this_mat[ , which(colSums(this_mat) == 0)] <- NULL#
	return(this_mat)#
}
plot(sort(rexp(100, rate = 1)))
plot(sort(rexp(100, rate = 1)), decreasing = TRUE)
plot(sort(rexp(100, rate = 1), decreasing = TRUE))
rexp(100, rate = 1)
rexp(100, rate = 100)
plot(sort(rexp(100, rate = 0.1), decreasing = TRUE))
rexp(100, rate = 0.1)
rexp(100, rate = 0.01)
log(rnorm(100, mean = 20, sd = 1))
plot(sort(rexp(100, rate = 0.01), decreasing = TRUE))
rexp(100, rate = 0.01)
plot(sort(rexp(100, rate = 0.1), decreasing = TRUE))
?binom
?rbinom
rbinom(n = 1, size = 10, prob = 0.5)
rbinom(n = 10, size = 10, prob = 0.5)
rbinom(n = 10, size = 2, prob = 0.5)
rbinom(n = 10, size = 1, prob = 0.5)
rbinom(n = 10, size = 1, prob = 0.5)
rbinom(n = 100, size = 1, prob = 0.2)
test_matrix <- matrix(data = rbinom(n = 100, size = 1, prob = 0.2), nrow = 10)
test_matrix
rowSums(test_matrix)
colSums(test_matrix)
plot(sort(rexp(100, rate = 0.1), decreasing = TRUE))
dim(test_matrix)
rowSums(test_matrix)
colSums(test_matrix)
prune_absent(test_matrix)
this_mat <- test_matrix
rowSums(this_mat)
which(rowSums(this_mat) == 0)
this_mat[which(rowSums(this_mat) == 0) , ]
this_mat[ , which(colSums(this_mat) == 0)]
this_mat[which(rowSums(this_mat) == 0) , ] <- NULL
this_mat[which(rowSums(this_mat) != 0) , ]
this_mat <- this_mat[which(rowSums(this_mat) != 0) , ]
this_mat
rowSums(this_mat)
rm(this_mat)
prune_absent <- function(this_mat){#
	this_mat <- this_mat[which(rowSums(this_mat) != 0) , ]#
	this_mat <- this_mat[ , which(colSums(this_mat) != 0)]#
	return(this_mat)#
}#
test_matrix <- matrix(data = rbinom(n = 100, size = 1, prob = 0.2), nrow = 10)#
#
dim(test_matrix)#
#
rowSums(test_matrix)#
colSums(test_matrix)
prune_absent(test_matrix)
rowSums(prune_absent(test_matrix))
colSums(prune_absent(test_matrix))
colSums(prune_absent(test_matrix))
dim(prune_absent(test_matrix))
dim(test_matrix)
lapply(mat_empirical, prune_absent)
sapply(lapply(mat_empirical, prune_absent), ncol)
sapply(mat_empirical, ncol)
sapply(lapply(mat_empirical, prune_absent), nrow)
length(lapply(mat_empirical, prune_absent))
# First, you must set your working directory to extinctions/Analysis#
#
# point to the data directory#
data_dir <- file.path("..", "Data")#
#
# point to the figure directory to write figures#
fig_dir <- file.path("..", "Figures")#
#
# load the functions#
sapply(list.files(pattern="[.]R$", path="functions/", full.names=TRUE), source)#
# source("functions/netcascade_JO.R")#
# source("functions/extinction_cascader.R")#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
# load all networks in that directory#
emp_net_files <- dir(path = emp_net_path, pattern = "*.txt") #Plant-pollinator weighted nets#
emp_nets <- list()#
for(p in 1:length(emp_net_files)){#
	emp_nets[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_net_files[p])))#
}
emp_nets
# point to the data directory#
data_dir <- file.path("..", "Data")#
#
# point to the figure directory to write figures#
fig_dir <- file.path("..", "Figures")#
#
# load the functions#
sapply(list.files(pattern="[.]R$", path="functions/", full.names=TRUE), source)#
# source("functions/netcascade_JO.R")#
# source("functions/extinction_cascader.R")#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
# load all networks in that directory#
emp_net_files <- dir(path = emp_net_path, pattern = "*.txt") #Plant-pollinator weighted nets#
emp_nets <- list()#
for(p in 1:length(emp_net_files)){#
	emp_nets[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_net_files[p])))#
}#
# NCEAS IWDB pollination networks#
poll_net_path <- file.path(data_dir, "NCEAS_text_files/plant_pollinator")#
# skip "kevan_f.txt"#
poll_net_files <- dir(path = poll_net_path, pattern = "*.txt")#
poll_net_files <- poll_net_files[!poll_net_files == "kevan_f.txt"] # this file is not square (has a row with not enough columns)#
poll_nets <- list()#
for(p in 1:length(poll_net_files)){#
	print(p)#
	poll_nets[[p]] <- as.matrix(read.table(file.path(poll_net_path, poll_net_files[p])))#
}#
#
# NCEAS IWDB seed disperser networks#
seed_net_path <- file.path(data_dir, "NCEAS_text_files/seed_disperser")#
seed_net_files <- dir(path = seed_net_path, pattern = "*.txt") #
seed_nets <- list()#
for(p in 1:length(seed_net_files)){#
	seed_nets[[p]] <- as.matrix(read.table(file.path(seed_net_path, seed_net_files[p])))#
}#
#
# NCEAS IWDB seed disperser networks#
antplant_net_path <- file.path(data_dir, "NCEAS_text_files/ant_plant")#
antplant_net_files <- dir(path = antplant_net_path, pattern = "*.txt") #
antplant_nets <- list()#
for(p in 1:length(antplant_net_files)){#
	antplant_nets[[p]] <- as.matrix(read.table(file.path(antplant_net_path, antplant_net_files[p])))#
}
# NCEAS IWDB seed disperser networks#
antplant_net_path <- file.path(data_dir, "NCEAS_text_files/ant_plant")#
antplant_net_files <- dir(path = antplant_net_path, pattern = "*.txt") #
antplant_nets <- list()#
for(p in 1:length(antplant_net_files)){#
	antplant_nets[[p]] <- as.matrix(read.table(file.path(antplant_net_path, antplant_net_files[p])))#
}
# point to the data directory#
data_dir <- file.path("..", "Data")#
#
# point to the figure directory to write figures#
fig_dir <- file.path("..", "Figures")#
#
# load the functions#
sapply(list.files(pattern="[.]R$", path="functions/", full.names=TRUE), source)#
# source("functions/netcascade_JO.R")#
# source("functions/extinction_cascader.R")#
# path to directory containing empirical networks:#
emp_net_path <- file.path(data_dir, "nets_emp")#
# load all networks in that directory#
emp_net_files <- dir(path = emp_net_path, pattern = "*.txt") #Plant-pollinator weighted nets#
emp_nets <- list()#
for(p in 1:length(emp_net_files)){#
	emp_nets[[p]] <- as.matrix(read.table(file.path(emp_net_path, emp_net_files[p])))#
}#
# NCEAS IWDB pollination networks#
poll_net_path <- file.path(data_dir, "NCEAS_text_files/plant_pollinator")#
# skip "kevan_f.txt"#
poll_net_files <- dir(path = poll_net_path, pattern = "*.txt")#
poll_net_files <- poll_net_files[!poll_net_files == "kevan_f.txt"] # this file is not square (has a row with not enough columns)#
poll_nets <- list()#
for(p in 1:length(poll_net_files)){#
	poll_nets[[p]] <- as.matrix(read.table(file.path(poll_net_path, poll_net_files[p])))#
}#
#
# NCEAS IWDB seed disperser networks#
seed_net_path <- file.path(data_dir, "NCEAS_text_files/seed_disperser")#
seed_net_files <- dir(path = seed_net_path, pattern = "*.txt") #
seed_nets <- list()#
for(p in 1:length(seed_net_files)){#
	seed_nets[[p]] <- as.matrix(read.table(file.path(seed_net_path, seed_net_files[p])))#
}#
#
# NCEAS IWDB seed disperser networks#
antplant_net_path <- file.path(data_dir, "NCEAS_text_files/ant_plant")#
antplant_net_files <- dir(path = antplant_net_path, pattern = "*.txt") #
antplant_nets <- list()#
for(p in 1:length(antplant_net_files)){#
	antplant_nets[[p]] <- as.matrix(read.table(file.path(antplant_net_path, antplant_net_files[p])))#
}
mat_empirical <- c(emp_nets, poll_nets, seed_nets, antplant_nets)
length(mat_empirical) # 32 (+5 seed)
mat_empirical[#
	which(#
		sapply(#
			mat_empirical, #
			max#
		) < 2#
	)#
] <- NULL#
length(mat_empirical) # 11 (+3 seed)
mat_empirical <- c(emp_nets, poll_nets, seed_nets, antplant_nets)
mat_empirical <- c(poll_nets, seed_nets, antplant_nets)
length(mat_empirical) # 32 (+5 seed; 51 for all)
mat_empirical <- c(poll_nets, seed_nets, antplant_nets)#
# mat_empirical <- poll_nets#
#
length(mat_empirical) # 42 for all
mat_empirical <- mat_empirical[which(sapply(mat_empirical, is.numeric))]
length(mat_empirical)
mat_empirical
mat_empirical[#
	which(#
		sapply(#
			mat_empirical, #
			max#
		) < 2#
	)#
] <- NULL#
length(mat_empirical) # 11 (+3 seed)
# remove rows or columns that doesn't interact with anyone #
# this function will remove species that do not have any interactions#
prune_absent <- function(this_mat){#
	this_mat <- this_mat[which(rowSums(this_mat) != 0) , ]#
	this_mat <- this_mat[ , which(colSums(this_mat) != 0)]#
	return(this_mat)#
}
length(lapply(mat_empirical, prune_absent))
length(mat_empirical) # 11 (+3 seed)
prune_absent <- function(this_mat){#
	this_mat <- this_mat[which(rowSums(this_mat) != 0) , ]#
	this_mat <- this_mat[ , which(colSums(this_mat) != 0)]#
	return(this_mat)#
}#
#
length(lapply(mat_empirical, prune_absent))
mat_empirical
length(mat_empirical) # 11 (+3 seed)
# remove rows or columns that doesn't interact with anyone #
# this function will remove species that do not have any interactions#
prune_absent <- function(this_mat){#
	this_mat <- this_mat[which(rowSums(this_mat) != 0) , ]#
	this_mat <- this_mat[ , which(colSums(this_mat) != 0)]#
	return(this_mat)#
}#
#
length(lapply(mat_empirical, prune_absent))
lapply(mat_empirical, prune_absent)
sapply(lapply(mat_empirical, prune_absent), rowSums)
mat_empirical <- lapply(mat_empirical, prune_absent)
length(mat_empirical)
length(mat_empirical) # 22 (+3 seed)
beta.par <- matrix(c(0.1, 1, 0.5, 1, 1, 1, 3, 3, 4, 0.1, 0.2, 0.2), byrow = TRUE, ncol = 2)#
rownames(beta.par)=c("exp","power","unif","normal","left", "bimod")#
R_options <- c("VA_low", "VA_med", "VA_high", rownames(beta.par))#
#
R_by_guild <- expand.grid(R_options, R_options)#
#
R_combo_names <- apply(X = as.matrix(R_by_guild), MARGIN = 1, FUN = function(x) paste(x, sep = "", collapse = ""))#
############################################################
#------------- RUN THE SIMULATIONS#
############################################################
N_iterations <- 10#
#
R_combo_out <- list()#
#
for(Rcombo in 1:nrow(R_by_guild)){#
	current_Rrows <- as.character(R_by_guild[Rcombo,1])#
	current_Rcols <- as.character(R_by_guild[Rcombo,2])#
	# DO THE SIMULATIONS ON EACH NETWORK#
	stored_events <- list()#
	just_extinctions <- list()#
	extinctions_by_guild <- list()#
	total_extinctions <- list()#
	total_cascades <- list()#
	cascade_frequency <- list()#
	for(i in 1:length(mat_empirical)){#
		mat <- mat_empirical[[i]]#
		if(min(c(rowSums(mat), colSums(mat))) == 0){#
			print("Hey, you have a species in your network that does not interact with any other species. The following functions will get stuck.")#
			next()#
		}#
		m<-nrow(mat)#
		n<-ncol(mat)#
		stored_events[[i]] <- extinction_cascader(imatrix = mat, R_row = current_Rrows, R_col = current_Rcols, nsims = N_iterations)#
		just_extinctions[[i]] <- lapply(stored_events[[i]], "[", c("lost_cols", "lost_rows"))#
		extinctions_by_guild[[i]] <- do.call(rbind, lapply(just_extinctions[[i]], lengths))#
		total_extinctions[[i]] <- rowSums(extinctions_by_guild[[i]])#
		total_cascades[[i]] <- sum(total_extinctions[[i]] > 1)#
		cascade_frequency[[i]] <- total_cascades[[i]]/length(stored_events[[i]])#
	}#
#
	R_combo_out[[Rcombo]] <- list(stored_events = stored_events, just_extinctions = just_extinctions, extinctions_by_guild = extinctions_by_guild, total_extinctions = total_extinctions, total_cascades = total_cascades, cascade_frequency = cascade_frequency)#
#
}#
names(R_combo_out) <- R_combo_names
lsos() # memory checking function
R_combo_names[1]
R_combo_names[4]
plot_list()#
for(i in 1:length(R_combo_out)){#
    plot_list[[i]] <- do.call(c, R_combo_out[[i]][[6]])#
    names(plot_list)[i] <- R_combo_names[i]  #
}
plot_list() <- list()#
for(i in 1:length(R_combo_out)){#
    plot_list[[i]] <- do.call(c, R_combo_out[[i]][[6]])#
    names(plot_list)[i] <- R_combo_names[i]  #
}
plot_list <- list()#
for(i in 1:length(R_combo_out)){#
    plot_list[[i]] <- do.call(c, R_combo_out[[i]][[6]])#
    names(plot_list)[i] <- R_combo_names[i]  #
}
plot_list
names(R_combo_out[[1]])
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print(batch)#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batches]]))#
  	print(i)#
}
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print(batch)#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]]))#
  	print(i)#
}
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print("batch")#
  print(batch)#
  print("batches[[batch]]")#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]]))#
	print("batches[[batch]]")#
  	print(i)#
}
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print("batch")#
  print(batch)#
  print("batches[[batch]]")#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]]))#
  	print("i")#
  	print(i)#
}
names(plot_list[[i]])
names(plot_list[i])
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print("batch")#
  print(batch)#
  print("batches[[batch]]")#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]]))#
  	print("i")#
  	print(i)#
  	names(plot_list[i])#
}
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print("batch")#
  print(batch)#
  print("batches[[batch]]")#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]])){#
  	print("i")#
  	print(batches[[batch]][i])#
  	names(plot_list[i])#
  }#
}
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print("batch")#
  print(batch)#
  print("batches[[batch]]")#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]])){#
  	print("i")#
  	print(batches[[batch]][i])#
  	names(plot_list[i])#
  set.seed(1)#
  par(mar = c(5,4,1,1))#
  stripchart(#
    x = plot_list[[batches[[batch]]]], #
    vertical = TRUE,#
    method = "jitter",#
    jitter = 0.2,#
    pch = 1, col = "black", #bg = "grey",#
    cex = 0.8,#
    # las = 2,#
    ylab = "Cascade frequency",#
    ylim = c(0,1),#
    las = 2, #
    xaxt = "n"#
    # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
  )#
  }#
}
plot_list[1]
plot_list[[1]]
batches[[1]]
plot_list
plot_list[[batches[1:9]]]
plot_list[[batches[1]]]
plot_list[[batches[[1]]]]
batches[[1]]
plot_list[[1:2]]
plot_list[1:2]
plot_list[c(1,2,3,5)]
plot_list[batches[[1]]]
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print("batch")#
  print(batch)#
  print("batches[[batch]]")#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]])){#
  	print("i")#
  	print(batches[[batch]][i])#
  	names(plot_list[i])#
  set.seed(1)#
  par(mar = c(5,4,1,1))#
  stripchart(#
    x = plot_list[batches[[batch]]], #
    vertical = TRUE,#
    method = "jitter",#
    jitter = 0.2,#
    pch = 1, col = "black", #bg = "grey",#
    cex = 0.8,#
    # las = 2,#
    ylab = "Cascade frequency",#
    ylim = c(0,1),#
    las = 2, #
    xaxt = "n"#
    # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
  )#
  }#
}
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  print("batch")#
  print(batch)#
  print("batches[[batch]]")#
  print(batches[[batch]])#
  for(i in 1:length(batches[[batch]])){#
  	print("i")#
  	print(batches[[batch]][i])#
  	names(plot_list[i])#
  set.seed(1)#
  par(mar = c(5,4,1,1))#
  stripchart(#
    x = plot_list[batches[[batch]]], #
    vertical = TRUE,#
    method = "jitter",#
    jitter = 0.2,#
    pch = 1, col = "black", #bg = "grey",#
    cex = 0.8,#
    # las = 2,#
    ylab = "Cascade frequency",#
    ylim = c(0,1),#
    las = 2, #
    xaxt = "n"#
    # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
  )#
    # add axis#
  axis(#
    side = 1,#
    at = 1:length(plot_list),#
    tick = TRUE,#
    labels = FALSE, #
    line = 0#
  )#
  # add labels#
  text(#
    x = 1:length(plot_list), #
    y = -0.1, #
    labels = names(plot_list), #
    xpd = TRUE, #
    srt = 45, #
    pos = 2, #
    cex = 0.8#
    )#
#
  }#
}
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  # print("batch")#
  # print(batch)#
  # print("batches[[batch]]")#
  # print(batches[[batch]])#
  # for(i in 1:length(batches[[batch]])){#
  	# print("i")#
  	# print(batches[[batch]][i])#
  	# names(plot_list[i])#
  set.seed(1)#
  par(mar = c(5,4,1,1))#
  stripchart(#
    x = plot_list[batches[[batch]]], #
    vertical = TRUE,#
    method = "jitter",#
    jitter = 0.2,#
    pch = 1, col = "black", #bg = "grey",#
    cex = 0.8,#
    # las = 2,#
    ylab = "Cascade frequency",#
    ylim = c(0,1),#
    las = 2, #
    xaxt = "n"#
    # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
  )#
    # add axis#
  axis(#
    side = 1,#
    at = 1:length(plot_list),#
    tick = TRUE,#
    labels = FALSE, #
    line = 0#
  )#
  # add labels#
  text(#
    x = 1:length(plot_list), #
    y = -0.1, #
    labels = names(plot_list), #
    xpd = TRUE, #
    srt = 45, #
    pos = 2, #
    cex = 0.8#
    )#
#
  # }#
}
names(plot_list[1:9])
plot_list[1:9]
names(plot_list[1:9])
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  # print("batch")#
  # print(batch)#
  # print("batches[[batch]]")#
  # print(batches[[batch]])#
  # for(i in 1:length(batches[[batch]])){#
  	# print("i")#
  	# print(batches[[batch]][i])#
  	# names(plot_list[i])#
  set.seed(1)#
  par(mar = c(5,4,1,1))#
  stripchart(#
    x = plot_list[batches[[batch]]], #
    vertical = TRUE,#
    method = "jitter",#
    jitter = 0.2,#
    pch = 1, col = "black", #bg = "grey",#
    cex = 0.8,#
    # las = 2,#
    ylab = "Cascade frequency",#
    ylim = c(0,1),#
    las = 2, #
    xaxt = "n"#
    # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
  )#
    # add axis#
  axis(#
    side = 1,#
    at = 1:length(plot_list[batches[[batch]]]),#
    tick = TRUE,#
    labels = FALSE, #
    line = 0#
  )#
  # add labels#
  text(#
    x = 1:length(plot_list[batches[[batch]]]), #
    y = -0.1, #
    labels = names(plot_list[batches[[batch]]]), #
    xpd = TRUE, #
    srt = 45, #
    pos = 2, #
    cex = 0.8#
    )#
#
  # }#
}
pdf(file = file.path(fig_dir, "cascade_freq_by_R_full.pdf"), width = 12, height = 7)#
batches <- list(1:9, 10:18, 19:27, 28:36, 37:45, 46:54, 55:63, 64:72, 73:81)#
for(batch in 1:length(batches)){#
  set.seed(1)#
  par(mar = c(5,4,1,1))#
  stripchart(#
    x = plot_list[batches[[batch]]], #
    vertical = TRUE,#
    method = "jitter",#
    jitter = 0.2,#
    pch = 1, col = "black", #bg = "grey",#
    cex = 0.8,#
    # las = 2,#
    ylab = "Cascade frequency",#
    ylim = c(0,1),#
    las = 2, #
    xaxt = "n"#
    # group.names = c("within tags,\nsingle PCR", "between tags,\nsingle PCR", "within tags,\ndouble PCR", "between tags,\ndouble PCR")#
  )#
    # add axis#
  axis(#
    side = 1,#
    at = 1:length(plot_list[batches[[batch]]]),#
    tick = TRUE,#
    labels = FALSE, #
    line = 0#
  )#
  # add labels#
  text(#
    x = 1:length(plot_list[batches[[batch]]]), #
    y = -0.1, #
    labels = names(plot_list[batches[[batch]]]), #
    xpd = TRUE, #
    srt = 45, #
    pos = 2, #
    cex = 0.8#
    )#
#
}#
#
dev.off()
apply(X = as.matrix(R_by_guild), MARGIN = 1, FUN = function(x) paste(x, sep = "-", collapse = ""))
apply(X = as.matrix(R_by_guild), MARGIN = 1, FUN = function(x) paste(x, sep = "-", collapse = "-"))
apply(X = as.matrix(R_by_guild), MARGIN = 1, FUN = function(x) paste(x, sep = "", collapse = "-"))
